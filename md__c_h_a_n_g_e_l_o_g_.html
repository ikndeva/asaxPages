<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asax02.neo: CHANGELOG.md: XML parser, ver2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="myextrastysheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">asax02.neo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__c_h_a_n_g_e_l_o_g_.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">CHANGELOG.md: XML parser, ver2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>$% \def\id#1{{\mathit{#1}}} \let\idit=\id \def\idbf#1{{\mathbf{#1}}} \def\idrm#1{{\mathrm{#1}}} \def\idtt#1{{\mathtt{#1}}} \def\idsf#1{{\mathsf{#1}}} \def\idcal#1{{\mathcal{#1}}} \newcommand{\sig}[1]{{\cal #1}} \newcommand{\op}[1]{{\tt #1}} $</p>
<p>Created by Hiroki Arimura (<a href="#" onclick="location.href='mai'+'lto:'+'ari'+'m@'+'ist'+'.h'+'oku'+'da'+'i.a'+'c.'+'jp'; return false;">arim@<span style="display: none;">.nosp@m.</span>ist.<span style="display: none;">.nosp@m.</span>hokud<span style="display: none;">.nosp@m.</span>ai.a<span style="display: none;">.nosp@m.</span>c.jp</a>) on 2016.08.01. <code>/Users/arim/Dropbox/tmp/xscan16all/asax02.neo/asax02.neo</code></p>
<h1>210504 Tue, 17:00-29.30, 12h: メモリ機構の再実装</h1>
<p>結局，XMachineのDescendant axisに関するCall機構の修正で，メモリがらみのバグが発生し，バグ取りに4時間近く費やした．結局は，Callクラスのメンバーの未整備など．</p>
<ul>
<li><a class="el" href="_ast_data_reader_8java.html">ast/AstDataReader.java</a>, <a class="el" href="_ast_data_writer_8java.html">AstDataWriter.java</a>: この二つの式の変数を用いた値の読み書きクラスの書き換えに，大半の時間がかかってしまった．</li>
<li><a class="el" href="_ast_assign_8java.html">ast/AstAssign.java</a>: DataWriterの代わりに，代入式を用いることとしｔ．コンパイルの見通しはよくなったのではないか．</li>
<li><a class="el" href="_x_c_adapt_8java.html">compile/XCAdapt.java</a>, <a class="el" href="_x_c_push_8java.html">XCPush.java</a>: 上記に関連して，コンパイラのクエリ変換文の描き直しも必要だった．</li>
</ul>
<p>変数をast.AstVarとframe.VarKeyに分離する．単一化情報&lt;tt&gt;XTypeItemは，<code>VarKey</code>には含めずに，ast.AstVarに保持させる．</p>
<ul>
<li><a class="el" href="_ref_8java.html">machine/Ref.java</a>: frame.VarKeyに再編成する．</li>
<li>今回の作業で生じたバグの副作用として，Runtime例外を用いた，システム内部のダンプ機構が整備できたのはよかった．</li>
</ul>
<h2>TODO</h2>
<ul>
<li>依然として，先祖軸とワイルドカードの組合せ時の実行エラーがとれない．これは仕様の問題か？</li>
<li><a class="el" href="_ast_data_reader_8java.html">ast/AstDataReader.java</a>: DataReaderとWriterに関しては，型ごとにノードを変える必要はないようである．仮想機械語命令の生成レベルで吸収すれば良い．</li>
</ul>
<h1>210503 Mon, 15:30-: エラー対応</h1>
<p>走行機構は，落ち着いているので，そろそろ実行時のエラー対応を行う必要がある．</p>
<ul>
<li>構文解析エラー</li>
<li>イベント走査エラー</li>
<li>メモリエラー</li>
</ul>
<p>それぞれ異なるが，基本的には，エラーが</p>
<ul>
<li>エラーが起きた時点と場所の同定</li>
</ul>
<p>ができる情報を記録し，表示する必要がある．</p>
<h1>210502 Sun, 20:00-29:00：コードまとめ，0503 Mon 05:00-07:00: バグ対応</h1>
<p>昨日分岐したブランチで，パス式と文字列式の構文改訂作業を完了し，masterブランチに合併し，作業を一旦終えた．</p>
<p>パス式の子孫軸の復活に関して，テストをしていたところ，targetプロセスが子孫軸をもつ（フレキシブルな）ときに，フレームスタックのアクセス時の番地逸脱のバグを発見した．対応は次回．</p>
<h2>パス式の構文の変更</h2>
<p>パス式のAxis区切りを，スラッシュ系（'/'）からドット系（'.'）へ変更した． さらに，トップのタグにも子軸か子孫軸の記号を付与することとして，任意のパスはドット'.'で始まるようにして，名前や文字列と区別が付くようにした．パス式の子孫軸も復活させた．</p>
<p>通常のXPath式との違い</p>
<ul>
<li>子供軸は&lsquo;&rsquo;.'`．現在のノードの直下の要素を表す</li>
<li>子孫軸は&lsquo;&rsquo;.*'`．現在のノードの下方の要素を表す．</li>
<li>パスの先頭には，必ず子供軸または子孫軸のどちらかの軸が付く．</li>
</ul>
<p>正しいパス式の例</p>
<ul>
<li><code>.dblp.article</code></li>
<li><code>.dblp.(article|inproceedings)</code></li>
<li><code>.*article</code></li>
<li><code>.dblp.*(article|inproceedings)</code></li>
</ul>
<h2>文字列式の構文の変更</h2>
<p>引用符として，スラッシュ（'/'）と二重引用符（'"'）の両方を使えるようにした． 一般に，項を1個以上含む文字列テンプレート式 <code>/xxx{{}}yyy...zzz{{}}www/</code>の内部では，安全のため，両方の引用符と，項出力のための中かっこの使用を禁止し，必要な場合は，これらの文字をバックスラッシュ'\'でエスケープして用いることとした．</p>
<div class="fragment"><div class="line">文字列テンプレート式の内部で許される文字</div>
<div class="line">## 禁止文字</div>
<div class="line">&#39;/&#39;（スラッシュ）, &#39;&quot;&#39;（二重引用符）, &#39;\&#39;&#39;（単一引用符）, &#39;{&#39;（左中かっこ）, &#39;}&#39;（右中かっこ）</div>
<div class="line"> </div>
<div class="line">## エスケープ文字</div>
<div class="line">&#39;\/&#39; | &#39;\&quot;&#39; | &#39;\{&#39; | &#39;\}&#39; | &#39;\\&#39; | &#39;\n&#39;  | &#39;\r&#39; | &#39;\t&#39;  | &#39;\b&#39;| &#39;\f&#39; </div>
</div><!-- fragment --><p>項を含まない通常の定数文字列については，スラッシュ（'/'）囲みの文字列の内部では二重引用符を，二重引用符（'"'）囲みの文字列の内部ではスラッシュを使用して良いとした．</p>
<p>正しい文字列の例</p><ul>
<li><code>"../dblp/article"</code>：正しい文字列</li>
<li><code>/..\/dblp\/article/</code>: 上と同じ文字列を表す．</li>
</ul>
<h2>その他</h2>
<ul>
<li>parse/query.g4: 非終端記号<code>strExpr</code>の見直し．シェルコマンド引数での引用符の変換事故を避けるために，引用符として，単一引用符（&lsquo;&rsquo;<code>）系と二重引用符（</code>"<code>）系の他に，スラッシュ系（</code>/`）を使えるようにする．</li>
<li>machine/XMachine.java: バグ解消．空テキストでnullが返り，CmdGetTextでOVMが停止するエラーを解決した．<code>String getText()</code>において，<code>this.event().getText()</code>の返り値がnullならば，長さ0の空語""を返すように修正した．本来は，イベント走査器がnullでなく，空語を返すようにすべきだが，ここで吸収するのが，走査器に依存せずバグを回避できて，安全である．</li>
</ul>
<h2>バグ，未解決</h2>
<p>各種のテストコードを，新しい構文に修正して走らせていたら，バグを見つけた． フレームスタックのメモリエラーである．フレームポインタが，フレームスタックの上端を1つはみ出ている． これは，結構深刻かもしれない．</p>
<div class="fragment"><div class="line">$ make all &amp;&amp; echo &#39;from open(&quot;../data/dblp1K.xml&quot;) go .*% [ .@key ] return &quot;{{ $label }} {{ .@key }} {{ .title }}&quot; ;&#39; | time  javaexec app.Match -t1</div>
<div class="line">@query from [stdin]: &#39;from open(&quot;../data/dblp1K.xml&quot;) go .*% [ .@key ] return &quot;{{ $label }} {{ .@key }} {{ .title }}&quot; ;&#39;</div>
<div class="line">@XC.compile and @XM.create...</div>
<div class="line">Exception in thread &quot;main&quot; java.lang.AssertionError: fp is out of bound: fp=14 REC.size=14</div>
<div class="line">    at frame.FrameStackUni._lookupMemCell(FrameStackUni.java:274)</div>
<div class="line">    at frame.FrameStackUni.fetchMemCell(FrameStackUni.java:254)</div>
<div class="line">    at frame.FrameStackUni.fetchBooleanHolder(FrameStackUni.java:303)</div>
<div class="line">    at cmd.CommandBoolean$CmdBoolLoad.exec(CommandBoolean.java:60)</div>
<div class="line">    at machine.OVMachine.execCommands(OVMachine.java:159)</div>
<div class="line">    at machine.XMachine.execPostCall(XMachine.java:703)</div>
<div class="line">    at machine.XMachine.execETAG(XMachine.java:684)</div>
<div class="line">    at machine.XMachine.exec(XMachine.java:475)</div>
<div class="line">    at machine.XMachine.scanFromSourceWithTagMaskMap(XMachine.java:443)</div>
<div class="line">    at machine.XMachine.scanFromSource(XMachine.java:420)</div>
<div class="line">    at cmd.CommandBase$CmdScanLoop.exec(CommandBase.java:479)</div>
<div class="line">    at machine.OVMachine.execCommands(OVMachine.java:159)</div>
<div class="line">    at machine.XMachine.execBLOCK(XMachine.java:567)</div>
<div class="line">    at app.Match.main(Match.java:647)</div>
<div class="line">        0.45 real         0.77 user         0.09 sys</div>
<div class="line">arim@java$</div>
</div><!-- fragment --><p>解決の糸口がわかった．次はmakefileのソースである．</p>
<div class="fragment"><div class="line">##バグあり</div>
<div class="line">HOG_DBLP_BUG1=&#39;from open(&quot;../data/dblp1K.xml&quot;) go .*% [ .@key ] return &quot;{{ $label }} {{ .@key }} {{ .title }}&quot; ;&#39;</div>
<div class="line">test.dblp.bug1:</div>
<div class="line">    make all &amp;&amp; echo $(HOG_DBLP_BUG1) | time  javaexec app.Match -t1</div>
</div><!-- fragment --><h2>推理1</h2>
<p>上記のmake本体で，<code>$label</code>のために，シェルから実行すると先頭文字が削れて<code>abel</code>という変数が出現しているので，そのためかと思った．しかし，この場合は，「コンパイル時に宣言されてない変数」というエラーが出るようだ．</p>
<h2>推理2</h2>
<p>下記は，エラーが生じる最小構成のクエリである．データは上記と同じである． 上記のバグは，子孫軸とワイルドカードを組み合わせると起きるようだ．</p>
<ul>
<li><code>.*%.% [ .@key ] return "{{ .@key }}"</code> =&gt; メモリエラー</li>
<li><code>.dblp.% [ .@key ] return "{{ .@key }}"</code> =&gt; 正常</li>
<li><code>.%.% [ .@key ] return "{{ .@key }}"</code> =&gt; 正常</li>
<li><code>.*%.% [ .@key ] return "{{ .@key }}"</code> =&gt; メモリエラー</li>
<li><code>.*dblp.% [ .@key ] return "{{ .@key }}"</code> =&gt; 正常</li>
</ul>
<p>子孫軸とワイルドカードがあるために，同じブロック（クエリ）のフレームが複数箇所できているのかもしれない．面倒だが，フレーム割り付けの詳細なログをみるのが早そうだ．</p>
<p>この種の子孫軸とワイルドカードの組合せは，禁止すべきかもしれない．</p>
<h1>210502 Sun, 13:30-16:30: 文書作成 Design of Query Syntax</h1>
<p>文書210502 Design of Query Syntaxを作成．ブロック呼び出しの実装のために，フレームスタックと変数機構を棚卸しした．</p>
<h1>210501 Sat, 16:30-18:00:</h1>
<ul>
<li>Match.java: パッケージappへ移動．関連のjavaexec, jarexec, xscan コマンドの修正．</li>
<li>util/YamlBuf.java: APIの整理．</li>
</ul>
<h2>TODO</h2>
<ul>
<li>app/Match.java: オプション-iの復活．そのために，ScanFromを，input stream quantifierと, blockに分解する． <div class="fragment"><div class="line">from open(infile) do query </div>
<div class="line">=&gt; </div>
<div class="line">def exec(query, es, os): </div>
<div class="line">  for ev in is.events() do </div>
<div class="line">    query.exec(ev, os)</div>
<div class="line">    </div>
<div class="line">var es = sys.stdin   #入力の割り当て</div>
<div class="line">var os = sys.stdout  #出力の割り当て</div>
<div class="line">do  #ブロックの開始</div>
<div class="line">  var es = fopen(infile)    #同じ名前の変数で隠蔽</div>
<div class="line">  exec(query)</div>
<div class="line">end #ブロックの終了</div>
</div><!-- fragment --></li>
<li><a class="el" href="_ast_scan_from_8java.html">ast/AstScanFrom.java</a>: 関連して<code>ScanFrom</code>から，ソースを切り離す．astとcmdの両方で．</li>
</ul>
<h1>210429 Thu, 昭和の日, 28:00-28:50 報告: 現在のコードの性能</h1>
<p>データとしてdblp.xml, 2.9GBを用いて，現在のコードの性能を測定してみた．計算機環境は，Intel Core i7, 3GHz, dual cores, 16GB memoryを用いた．wcコマンドでの走査は約9secであった．</p>
<div class="fragment"><div class="line">$ time wc ../../data/dblp/dblp.xml</div>
<div class="line">70440480 167339864 2910993386 ../../data/dblp/dblp.xml</div>
<div class="line"> </div>
<div class="line">real    0m8.995s</div>
<div class="line">user    0m8.548s</div>
<div class="line">sys 0m0.421s</div>
</div><!-- fragment --><p>使用したクエリは，タイトルが<code>XML</code>を部分文字列として含み，出版年が2000年以降の articleまたはinproceedingsエントリを全て出力するものである．このクエリに対して上記のPC上で，xscanの実行は約220secであった．回として8871個のレコードに照合している．スループットは約15MB/secである．まあまあではないかと思う．メモリはたいしたことない．何より，メモリに貯めず，バグを出さずに，ストリーム的に動くことが素晴らしい．</p>
<div class="fragment"><div class="line">$ date; echo &#39;from open(&quot;../../data/dblp/dblp.xml&quot;) go </div>
<div class="line">  dblp/(article|inproceedings) [ title =~ &quot;XML&quot; and year &gt;= 2000 ] </div>
<div class="line">  return </div>
<div class="line">    &quot;{{$nm}}:{{$nr}}: TY[{{ $label }}] PY[{{year}}] </div>
<div class="line">    AU[{{author return &quot;{{ text() }}; &quot; }}] TI[{{title}}]&quot; &#39; </div>
<div class="line">  | time  javaexec Match -t1  &gt; log.dblp; date</div>
<div class="line"> </div>
<div class="line">2021年 4月30日 金曜日 04時34分58秒 JST</div>
<div class="line">@XC.compile and @XM.create...</div>
<div class="line">{</div>
<div class="line">  @processing time (sec): { total: 219.315, compile: 0.302, running: 219.014 },</div>
<div class="line">  @processing time (min): { total: 3.655, compile: 0.005, running: 3.650 },</div>
<div class="line">  @matches: { numEventsRead:315674321, numVisits:39866492, numMatches:8871, numSkipped:0 }</div>
<div class="line">}</div>
<div class="line">      219.60 real       214.65 user         2.72 sys</div>
<div class="line">2021年 4月30日 金曜日 04時38分37秒 JST</div>
<div class="line">arim@java$</div>
</div><!-- fragment --> <h1>210419 Thu, 昭和の日, 17:00-26:30 コード, 26:30-28:00 報告, 11h: 中間言語のための再設計の実装とリファクタリング</h1>
<p>コンパイルと清書出力の両方を簡素化するために，AstNode階層の再構築と，関連の作業を行った．対応するコンパイラのパイプラインも手直しした．実行系は，全体に動的な機構を導入することで，実装の簡素化と表現力の向上を図った．</p>
<p>Gitで，masterブランチから，asax03monostackブランチを分岐し，最後にffで1本にマージし，主幹に戻している．</p>
<p>まとめると，今日の作業で，第3期の中間言語作成のfeasibility studyとして，だいたい一区切りついたと思う．全体としては，これから行うXscanの実行系の上に乗る中間言語を実現するための準備のフェーズといえる．</p>
<ul>
<li>ast/Node.java: クラスAstNodeを抽象化して，インタフェースNodeを作成し，合わせてインタフェースNavigatableを改良した．</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">interface </span>Node <span class="keyword">extends</span> XFormattable { </div>
<div class="line">    <span class="keyword">public</span> Typable getTyping(); </div>
<div class="line">    <span class="keyword">public</span> String data(); </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">boolean</span> notToEmit(); </div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">int</span> numChildren(); </div>
<div class="line">    <span class="keyword">public</span> Node getChild(<span class="keywordtype">int</span> i); </div>
<div class="line">    <span class="keyword">public</span> Node setChild(<span class="keywordtype">int</span> i, Node child); </div>
<div class="line">    <span class="keyword">public</span> String toStr();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">interface </span>NodeUnary <span class="keyword">extends</span> Node {</div>
<div class="line">      <span class="keyword">public</span> Node getTheChild();    </div>
<div class="line">      <span class="keyword">public</span> Node setTheChild(Node child);  </div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">interface </span>XFormattable {</div>
<div class="line">    <span class="keywordtype">boolean</span> notToEmit(); </div>
<div class="line">    </div>
<div class="line">　　</div>
<div class="line">　　public <span class="keyword">interface </span>Navigatable <span class="keyword">extends</span> XFormattable {</div>
<div class="line">　　　String getLabelString();</div>
<div class="line">     <span class="keywordtype">int</span> numChildrenNav();  </div>
<div class="line">     XFormattable getChildNav(<span class="keywordtype">int</span> i); </div>
<div class="line">     String getFieldNav(<span class="keywordtype">int</span> i);     </div>
<div class="line">     Style getStyle();  </div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><a class="el" href="_ast_node_8java.html">ast/AstNode.java</a>, AstNodeBranch: インタフェースNodeにしたがい，次のクラスを整理したAstNode =&gt; AstNodeBase, AstNodeBranch =&gt; AstNode. AstNodeBranchは廃止した．</li>
</ul>
<div class="fragment"><div class="line">public abstract class AstNode extends AstNodeBase </div>
<div class="line">  implements Node, XFormattable.Navigatable, XFormattable.TypedFormattable; </div>
</div><!-- fragment --><ul>
<li>ast/AstTerminal.java, AstAtom.java: 対応する子をもたないノードのクラスを統廃合した．</li>
<li><a class="el" href="_ast_node_tagged_8java.html">ast/AstNodeTagged.java</a>: 明示的にタイプ配列<code>List&lt;XTypeItem&gt; types</code>を持たせて，タグと，タイプ，子のアクセッサ（getter）を一様に扱うようにした．</li>
<li><a class="el" href="_x_formattable_8java.html">format/XFormattable.java</a>: インタフェース<code>Navigatable</code>に表示の昨日を集約し，<code>LabeledFormattable</code>と<code>Terminatable</code>を廃止した．</li>
<li><a class="el" href="_node_formatter_simple_8java.html">format/NodeFormatterSimple.java</a>: インタフェースの簡略化に伴い，タグと型情報の表示方法を簡略にした．</li>
<li><a class="el" href="_basic_typing_8java.html">type/BasicTyping.java</a>, <a class="el" href="_child_hom_typing_8java.html">ChildHomTyping.java</a>: <code>ChildHomTyping</code>を中心に，子型のアクセスと表示を再設計した．</li>
<li><a class="el" href="_sent_list_8java.html">ast/SentList.java</a>: ast/AstList.javaを，SentListに集約した. BlockとStepに関する式列は，SentListで扱うこととした．DataWrapperもAstlistの内部クラスとした．</li>
<li><a class="el" href="_block_base_8java.html" title="190113: Renamed from StepExpr.java 180722: Separated from AstNode.java 180228: Modified by arim@ist....">ast/BlockBase.java</a>, <a class="el" href="_block_8java.html" title="190113: Renamed from StepExpr.java 180722: Separated from AstNode.java 180228: Modified by arim@ist....">Block.java</a>, <a class="el" href="_step_8java.html" title="190113: Renamed from StepExpr.java 180722: Separated from AstNode.java 180228: Modified by arim@ist....">Step.java</a>: BlockBaseを実質的な仮想クラスとして，BlockとStepのgetterを整備した．タグ名称も整理している．</li>
<li>ast/*.java: AstNode（旧AstBranch）の子リストの型を<code>List&lt;Node&gt; children_</code>としたのに合わせて，パッケージastとcompile中に現れる大多数の<code>AstNode</code>型を，インタフェース<code>Node</code>型に置き換えた．パッケージparse中のノードの生成部分では，AstNodeの部分クラスの型スイッチを用いて扱うこととした．</li>
<li>compile/XC*.java: パッケージcompile中のコンパイラコードで，<code>AstNode</code>型を，インタフェース<code>Node</code>型に置き換えた．一部は，<code>AstNode</code>の部型の型スイッチで対応している．パッケージparse内のAstParserとAstNodeFactoryも一部手直しが必要だった．</li>
<li><a class="el" href="_block_8java.html" title="190113: Renamed from StepExpr.java 180722: Separated from AstNode.java 180228: Modified by arim@ist....">ast/Block.java</a>, <a class="el" href="_x_c_typing_8java.html">compile/XCTyping.java</a>: クエリのトップレベルで，変数宣言と代入ができるように，クラスStepと同様に，クラスBlockに変数リスト（RefList）を持たせた．このため，クラスXCTypingの最上位手続きtypingで，最上部のBlockの変数リストの設定を追加した．正しく動作しているようである．</li>
<li>ast/StringRel.java, <a class="el" href="_command_string_8java.html">cmd/CommandString.java</a>: テキストの文字列パターン照合で，パターンに従来の文字列リテラルだけでなく，項を含む任意の文字列式を用いられるようにした．これに伴い，ast/AstTemplateの引用符が除去されないエラーを解消した．パターンに文字列テンプレートを使えるようになった．このため，StringMatchRelの<code>gencode</code>関数と仮想機械命令<code>CmdStrStringMatch</code>において，テキスト引数とパターン引数の両方をスタックから取り出す2スタック引数形式とした．却って，コードが以前より簡単になった．</li>
</ul>
<h2>TODO</h2>
<ul>
<li>当初の目標であるプロセスと関数の呼び出し方式を，実装する．現在の<code>Step</code>のコンパイル方式の拡張人なるはずである．EagerとLazyの2種の呼び出し方式も実装したい． それにより，現在の<code>Step</code>の呼び出し方式は，呼び出しグラフ中の関数呼び出しが一意であるときのみ可能なものであり，呼び出し時の返値のフレーム渡しが必要ない，効率良いLazyであることが言えると思う．</li>
<li>関数呼び出しにおいては，単一値の他，多値の返却も可能にする．また，一般的な呼び出し手順を確立することで，従来のパス言語のステップ呼び出しを，中間言語を経由して，仮想機械コードにコンパイルできるようにしたい．見通しがよくなるはずである．</li>
<li>また，手続き的な中間言語自体も公開したい．Java scriptのような構文と実装方法をもつ言語である．オブジェクトは持たず，モジュール機構として，関数閉包を利用できると思う．</li>
</ul>
<p>動的実行関係</p>
<ul>
<li>ast/StringRel.java, <a class="el" href="_command_string_8java.html">cmd/CommandString.java</a>: テキストの正規表現照合のパターンの組み立てに，項を含む任意の文字列式を用いられるようにする．最終的な目標として，文字列を引数にとる仮想機械命令は，全て文字列引数をスタックから取るようにする．動的な機構を使うことで，性能にオーバーヘッドが出るが，表現力が大きく，実装は簡潔にしたい．</li>
<li>machine/XMachine.java, <a class="el" href="_ast_scan_from_8java.html">ast/AstScanFrom.java</a>: 入力ストリームを動的化したい．この入力源の動的化により，<code>ScanFrom</code>節は，プログラム式全体でただ一つしかない入力ストリームを表す変数<code>Instream $_</code>を，入力ソースに束縛する限量子の構文として，再構成できると思う．線形性を構文で表す訳である．2変数の場合は，joinが実現できる．</li>
</ul>
<p>スタック関係</p>
<ul>
<li><a class="el" href="_o_v_machine_8java.html">machine/OVMachine.java</a>: ．OVMのオペレーションスタックは，1本のObjectスタックと，型条件によるキャストを組み合わせて，簡単な実装にする． 動的型チェックもする．仮想機械命令の実行エラーの清書が容易になると期待できる．これは，すぐにでも実装できて，影響が少ないので，すぐやりたい．</li>
<li><a class="el" href="_frame_stack_uni_8java.html">frame/FrameStackUni.java</a>: フレームスタックも，型がわからない変数の動的な割り付けができるようにしたい．簡素化もできるのではないか．こちらは要検討である．</li>
</ul>
<h1>210419 Thu, 昭和の日, 5:00-10:00, 14:00-16:00 7h: AstNodeの再設計</h1>
<p>プロセス機構の再設計を受けて，AstNodeのクラス階層の再設計を行った．</p>
<h1>210428 Wed, 21:00-22:00, 1h: プロセス呼び出しの再設計</h1>
<p>プロセス呼び出し機構の再設計を行った．</p>
<h1>210425 Sun, 23:00-26:30, 3.5h: リファクタリング</h1>
<p>パッケージcompileの各手続きのリファクタリング．ブロック呼び出し全体を再設計したい． BlockBaseの下に，BlockとStepをおいた．</p>
<p>TODO:</p><ul>
<li>おそらく，Blockは，パスと帰り値を持たない点をのぞいて，Stepと同じにする必要があるのではないか？</li>
<li>XCPushについて，AstScanFromとStepについては整理の必要がある．</li>
</ul>
<h1>210423 Fri, 10:20-10:50, 30min: バグ</h1>
<ul>
<li><a class="el" href="_ast_math_oper_8java.html">ast/AstMathOper.java</a>: クラスBooleanOperの関数<code>void gencode(<a class="el" href="classcmd_1_1_cmd_list.html" title="仮想命令のリスト．">cmd.CmdList</a> code, <a class="el" href="classcmd_1_1_cmd_list.html" title="仮想命令のリスト．">cmd.CmdList</a> precode)</code>で，演算子のコードが生成されていなかったバグを解決した．AstBranchのインタフェースを変更した際に，while文をfor文に変えたが，空な子のスキップに関して添字が増加されていなかったため．正しく修正した．</li>
</ul>
<h1>210416 Fri, 10:00-11:00, 21:00-24:00: バグ</h1>
<p>久しぶりに，コードレビューをした．</p>
<h2>ノード依存の型推論の手続きから，ノードの関数型への委譲</h2>
<ul>
<li><a class="el" href="_x_c_typing_8java.html">compile/XCTyping.java</a>: 型推論のための再帰手続き<code>RecType</code>から，下記のノードクラスについて，ノード固有の型推論コードを除去した．</li>
<li><a class="el" href="_ast_if_8java.html" title="190115: Created by arim@ist.hokudai.ac.jp">ast/AstIf.java</a>: <code>AstIf</code>の型を実装した： ret:$T &lt;- cond:Boolean x then:$T x else: $T</li>
<li><a class="el" href="_ast_let_8java.html">ast/AstLet.java</a>: <code>AstLet</code>: ret:$T &lt;- sent:Void x term:$T</li>
<li><a class="el" href="_sent_list_8java.html">ast/SentList.java</a>: <code>SentList</code>の関数型として <code>ret:$T &lt;- (Inst:Void)^* x term:$T</code>を実装する．このために，BasicTypingのサブクラスとして，TailHomTypingを導入する．これは，特別な末尾の子<code>tail</code>をもち，<code>add()</code>は，<code>tail</code>以外の子列<code>children0</code>の末尾に追加する．常に，子列は<code>children := children0 + tail</code>を表す．</li>
</ul>
<h2>下記の実行時エラーを解決した．</h2>
<ul>
<li><a class="el" href="_x_c_typing_8java.html">compile/XCTyping.java</a>: 再帰手続き<code>recType()</code>の<code>AstIf</code>の片付けにバグがあった．<code>BasicTyping</code>の子 cond, then, elseの型付けが　type(then) :=: type(else) := Booleanとなっていたので，修正した．本来は <code>AstIf</code>の型付け規則を<code>recType()</code>から分離して，<code>AstIf</code>自体にもたせるべき．</li>
</ul>
<p>症状：実行<code>Make test.dblp</code>で，走行中に実行時エラーが起きる． </p><div class="fragment"><div class="line">arim@java$ make test.dblp</div>
<div class="line">echo &#39;from open(&quot;../data/dblp1K.xml&quot;) go dblp/(article|inproceedings) </div>
<div class="line">  [ title =~ &quot;Data&quot; and year &gt;= 1990 ] return </div>
<div class="line">  &quot;{{$nm}}:{{$nr}}: TY[{{ $label }}] PY[{{year}}] </div>
<div class="line">  AU[{{author return &quot;{{ text() }}; &quot; }}] TI[{{title}}]&quot; &#39; </div>
<div class="line">  | time  javaexec Match -t1</div>
<div class="line"> </div>
<div class="line">1:7: TY[article] PY[1997] AU[] TI[The 1995 SQL Reunion: People, Project, and Politics, May 29, 1995.]</div>
<div class="line">2:13: TY[article] PY[1994] AU[Frank Manola; ] TI[An Evaluation of Object-Oriented DBMS Developments: 1994 Edition.]</div>
<div class="line">3:19: TY[article] PY[1991] AU[Frank Manola; ] TI[Object Data Language Facilities for Multimedia Data Types.]</div>
<div class="line">4:26: TY[article] PY[1993] AU[Frank Manola; Sandra Heiler; ] TI[A &#39;RISC&#39; Object Model for Object System Interoperation: Concepts and Applications.]</div>
<div class="line"> </div>
<div class="line">Exception in thread &quot;main&quot; java.lang.AssertionError: pop: top_ must be nonnegative!: top_=-1</div>
<div class="line">    at util.StackBase.pop(StackBase.java:163)</div>
<div class="line">    at cmd.CommandString$CmdOStreamStore.exec(CommandString.java:86)</div>
<div class="line">    at machine.OVMachine.execCommands(OVMachine.java:155)</div>
<div class="line">    at machine.XMachine.execETAG(XMachine.java:718)</div>
<div class="line">    at machine.XMachine.exec(XMachine.java:526)</div>
<div class="line">    at machine.XMachine.scanFromSource(XMachine.java:488)</div>
<div class="line">    at machine.XMachine.scanFromSource(XMachine.java:461)</div>
<div class="line">    at cmd.CommandBase$CmdScanLoop.exec(CommandBase.java:503)</div>
<div class="line">    at machine.OVMachine.execCommands(OVMachine.java:155)</div>
<div class="line">    at machine.XMachine.execBLOCK(XMachine.java:774)</div>
<div class="line">    at Match.main(Match.java:651)</div>
<div class="line">        0.56 real         0.97 user         0.12 sys</div>
</div><!-- fragment --><h2>ターゲットクエリの述語エラー</h2>
<p>エラーを解決した．ターゲットクエリの述語を空にすると，実際には照合していても，照合数<code>numMatches</code>が0になる． </p><div class="fragment"><div class="line"># dblp/(article|inproceedings) [ True ] return &quot;{{ title }}&quot; ;</div>
<div class="line">=&gt; @matches: { numEventsRead:37295, numVisits:1692, numMatches:0, numSkipped:0 }</div>
</div><!-- fragment --><p>これは，出力時に，OVMのCmdIncMatch演算が，ターゲットクエリの命令列に正しく追加されないためである．次のように，ターゲットクエリにダミーの条件<code>true</code>を付けると，正しくコンパイルされる． </p><div class="fragment"><div class="line"># dblp/(article|inproceedings) [ True ] return &quot;{{ title }}&quot; ;</div>
<div class="line">=&gt; @matches: { numEventsRead:37295, numVisits:1692, numMatches:845, numSkipped:0 }</div>
</div><!-- fragment --><h1>210324 Thu, 10:30-13:30, 24:30-26:30, 5h: ノードへの斉次型の組み込み．未完．</h1>
<p>パッケージastのノードクラスに，ノードへの斉次型を組み込んだ．まだバグがとれない．</p>
<ul>
<li>ast: AstReturnとStepで同値類の型の伝搬がうまくいっていないようである．</li>
<li>ast.AstBranchTagged, Step: 清書がうまくいっていない．Getterによる子とchildrenリストによる子の出力が重複しているようだ．</li>
</ul>
<p>エラーの解析により，ノードの子が追加された時に，対応するtypingの子の型が追加されていないことが原因とわかった．解決のために，AstNodeTaggedとAstNodeTaggedSettableクラスの<code>addGetter</code>と<code>addGetterAndSetter</code>の引数に型を与えて，ノードの<code>typing</code>オブジェクトに子の型を追加するようにした．</p>
<p>TODO</p>
<p>BlockRuleとStepの子<code>sents</code>の型を取り出す時にエラーが起きている．nullになるようだ．</p>
<ul>
<li><a class="el" href="_x_c_typing_8java.html">compile/XCTyping.java</a>: バグはとれたようだ．</li>
<li><a class="el" href="_x_c_adapt_8java.html">compile/XCAdapt.java</a>: バグがのこっている．</li>
</ul>
<h1>210322 Mon, 26:00-29:00, 3h: 型推論とログオブジェクトの整理</h1>
<p>多相型推論を(大堀，プログラミング言語の基礎理論，共立)で勉強し，型項と推論手続きの概要を設計した．</p>
<p>コンパイルモジュールを修正する前に，ログオブジェクトの整理をした．</p>
<ul>
<li><a class="el" href="_trace_level_8java.html">TraceLevel.java</a>: ログオブジェクトに局所的なモジュールと出力レベルを持たせて，表記を簡略化した．</li>
<li>全体: 各モジュールに一つずつLOGオブジェクトを持たせることとして，不要なLOGオブジェクトを整理した．</li>
</ul>
<h2>TODO</h2>
<p>型推論手続きを完成させる．</p>
<p>まずコンパイルの対象である項を定める．項は，パッケージcompileの手続きで巡回可能な表現である．項: AstAtom, AstOper, ... </p><div class="fragment"><div class="line">///@brief コンパイルの対象である項．基本的にはAstNodeと一致する．</div>
<div class="line">Interface Term {</div>
<div class="line">  Term(): 返値に対応する新鮮な型変数を割り付ける．</div>
<div class="line">  int numChildren(): </div>
<div class="line">  Term getChild(int i): </div>
<div class="line">  void setChild(int i, Term t): `0\le i\le numChildren()` must holds. </div>
<div class="line">  void addChild(Term t): `numChildren()`を1つ増加させ，`typing().addType(new TypeItem(XType.Top))`を呼び出して新鮮な型変数を挿入する．</div>
<div class="line">}</div>
</div><!-- fragment --><p>多引数の関数型<code>t_0 x ... x t_{n-1} -&gt; t</code>を表す型項<code>T</code>を実装する．これは，次の演算をもつ． </p><div class="fragment"><div class="line">interface Typing {</div>
<div class="line">}</div>
<div class="line">class BasicTyping implements Typing {</div>
<div class="line">  BasicTyping(): 生成して，返値の型を設定する．</div>
<div class="line">  int numChildren(int i): 第i入力の要素を返す．</div>
<div class="line">  TypeItem getType(): 返値の要素を返す．</div>
<div class="line">  TypeItem getChildType(int i): 第i入力の要素を返す．</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//全ての子が異なる型をもち，互いに同値でない関数型．</div>
<div class="line">class HeteroTyping implements Typing {</div>
<div class="line">  HeteroTyping(XType xt): 生成して，返値の型を設定する．</div>
<div class="line">  void addChildType(XType xt1): 与えられた型`xt1`を子の型として追加する．</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//全ての子が同じ型をもち，互いに同値な関数型．親と子は同値でない．</div>
<div class="line">//例：AstRel: Bool&lt;-Number*</div>
<div class="line">class HomTyping extends BasicTyping {</div>
<div class="line">  HomTyping(XType xt, XType xt1): 生成して，返値型`xt`と子の型`xt1`を設定する．</div>
<div class="line">  void addChildType(): 登録した型`xt1`を子の型として追加する．</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//親と全ての子が同じ型をもち，同値な関数型．</div>
<div class="line">//例：AstMathOper: R &lt;- R* where R in {int, dbl, str, bool}</div>
<div class="line">class HomOperTyping extends BasicTyping {</div>
<div class="line">  HomOperTyping(XType xt, XType xt1): 生成して，返値型`xt`と子の型`xt1`を設定する．</div>
<div class="line">  void addChildType(): 登録した型`xt1`を子の型として追加する．</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>* type/XTyping.java: 型項を実装する．</li>
</ul>
<h1>210319 Fri, 18:00-20:00, 21:00-23:30, 4.5h: ScanFrom節の動的化．</h1>
<p>ScanFrom節を，入力ストリーム指定の節に，任意の文字列項を許すようにリファクタリングした．実装中． 各種の構文要素を汎化して実装する試みとして行なった．</p>
<p>これに先立ち，astパッケージのリファクタリングを行なった．</p><ul>
<li>ast/AstNodeBranch.java: SetterとGetterを通して，名前付きの子供にアクセスするようにした．これを順序付きの子として，<code>int numChildren()</code>と<code>AstNode getChild(int i)</code>, <code>void setChild(int i, AstNode child)</code>でアクセスすることとした．</li>
<li>ast/AstNodeBranch.java: インタフェース<code>Navigatable</code>のノードの清書演算<code>String getLabelString()</code>を，メソッド<code>data()</code>を呼び出す共通手続きとして1箇所にまとめた．</li>
<li><a class="el" href="_x_formattable_8java.html">format/XFormattable.java</a>: インタフェース<code>Navigatable</code>にノードの清書演算<code>String getLabelString()</code>を持たせた．これは，AstNodeBranchに各種の演算を集約するため．</li>
</ul>
<p>全体に，プログラム言語として，静的解析を減らして，動的な割り付けを行うようにする方針の一環である． そのためには，ASTノードに，これまでより高い表現力の型項を導入して，<code>compiler</code>の型推論を単純化する戦略がよさそうである．</p>
<p>クラス<code>AstNodeBranch</code>の順序付きの子アクセスの演算<code>int numChildren()</code>と<code>AstNode getChild(int i)</code>, <code>void setChild(int i, AstNode child)</code>を利用して，コンパイルコードの簡略化を行なった．</p>
<ul>
<li>compile/{XCType.java, <a class="el" href="_x_c_adapt_8java.html">XCAdapt.java</a>, <a class="el" href="_x_c_push_8java.html">XCPush.java</a>}: <code>AstNodeTagged</code>の部分クラスである<code>AstIf</code>, <code>AstReturn</code>, <code>BlockRule</code>に関して，不要な分岐処理を，AstBranchの処理に委譲して，コードの処理を簡略化した．ただし，型推論部分はさわっていない．</li>
</ul>
<h2>TODO</h2>
<p>compile/XCType.javaの型推論部分を，汎化すること．</p>
<h1>210319 Fri, 11:00-13:00, 2h: 出力節のバグ取り</h1>
<p>久しぶりにコードを実行したところ，出力節のバグが起きた． ステップの出力節のコンパイルを，WriteOStreamノードでラップしたif-then文で実装していることが原因である． この実装ではステップ<code>path [ cond ] return osent</code>の条件節<code>cond</code>が成立しない時に，<code>osent</code>の返り値がOVMachineのString stackにプッシュされていないにも関わらず，<code>CmdWriteOStream</code>の実行でString stackをポップするために，スタックの添字エラーが生じるもの．</p>
<p>根本的には，return clauseのストリクトネス解析を行い，全ての場合に正しくOVM StringStackに値が積まれるようにするような変換の実装が必要である． 今回は，応急措置として，次のようにした．</p><ul>
<li><a class="el" href="_ast_parser_8java.html">parse/AstParser.java</a>: 出力節を<code>if-then-else</code>節に変換して，<code>else</code>の場合は空文字列`<code>をOVM String Stack上に積むようにした．</code></li>
<li><code>cmd/CmdWriteOStream: 手続き</code>exec`を，OVM String stackから取り出した文字列値が空（長さが0）のときには，指定の出力ストリームへの出力をスキップするようにした．現在は，文字列が非空ならば，その文字列を出力ストリームへ書き出して，さらに改行を追加する仕様にしている．出力ストリームへの区切り文字の指定と合わせて，仕様を考える必要がある．</li>
</ul>
<h1>200901 Tue, 27:00-30:00, 3h: 数値と文字列の結合演算子の多相型的な実装</h1>
<p>Java風の文字列の結合演算子<code>+</code>を実装した。数値の可算<code>+</code>と文字列の結合演算子<code>+</code>は同じ演算子名をもつために、多相型的な型推論と型変換が必要である。多相型的な型推論と変換は、次の手順で実装した。</p>
<ul>
<li>parse/query.g4: Antlr4とAstParserによる構文解析では、加法的演算子<code>+</code>と<code>-</code>をもつ式を、前者をカテゴリarithAddTermPlusの式、後者をカテゴリarithAddTermMinusとして扱う。前者のノードの子供は、数値積項と文字列積項を区別せずに、カテゴリ arithOrStrMulTerm をもつ部分式として扱う。後者のノードの子供は、arithMulTermをもつ。</li>
<li>ast/AstOper.java: クラス<code>NumberOper</code>を分割して、カテゴリarithAddTermMinusとカテゴリarithAddTermPlusを、それぞれ保持するクラス<code>NumberOper</code>とサブクラス<code>NumberOrStrOper</code>を導入した。ここに、<code>NumberOrStrOper</code>を<code>NumberOper</code>のサブクラスとする。</li>
<li><a class="el" href="_ast_node_factory_8java.html">parse/AstNodeFactory.java</a>, <a class="el" href="_ast_parser_8java.html">AstParser.java</a>: 加法的演算子'+'と<code>-</code>をもつ式を、クラス<code>NumberOrStrOper</code>、および、クラス<code>NumberOper</code>のノードを根にもつ式として構文木を構築する。</li>
<li><a class="el" href="_x_c_adapt_8java.html">compile/XCAdapt.java</a>: コンパイル時にXCTypingの型推論によって割り当てられる、数値型<code>Integer</code>または、<code>Double</code>型、文字列型の<code>String</code>型のそれぞれに対して、対応する演算子型のクラスである<code>IntegerOper</code>、<code>DoubleOper</code>、<code>StringAddOper</code>のノードに置き換える処理を行う。ここに、<code>StringAddOper</code>のノードに変換する処理を新しく追加した。</li>
</ul>
<p>数値式と比較すると、文字列の結合式<code>S1+S2</code>が和項<code>s1+s2</code>に相当し、文字列のテンプレート式<code>"aa{{ e1 }}bbb{{ e2 }}ccc"</code>が積項<code>t1 * t2</code>に相当する。</p>
<p>以上により、次のクエリが書ける。ここで、出力に文字列テンプレート式と文字列結合式を用いている。文字列結合式に出現する部分式<code>author</code>を囲むカッコは省略しても良い。</p>
<div class="fragment"><div class="line">from open(&quot;../data/dblp1K.xml&quot;) </div>
<div class="line">  go dblp/(article|inproceedings) []  </div>
<div class="line">  &quot;year={{ year }} authors=[&quot;+(author)+&quot;] BIB&quot;</div>
</div><!-- fragment --><p>現在の静的な多相型処理では、基本的に、前段のantlr4による構文解析において型を混在させたまま型の和として扱い、後段の単一化をもちいた型推論と強制型変換で演算をダウンキャストする戦略を用いている。この方向を進めると、動的型付けを用いた計算に移行するのが自然かもしれない。現状では、まだ静的な型推論が可能である。</p>
<h3>TODO</h3>
<p>以前として、ステップの返り値のコンパイルにバグがある。次のif-thenクエリは、条件式がfalseのときに失敗する。これは、else側では、仮想機械のオペランドスタック上に、条件文から返り値がプッシュされないために、OStreamWriterがオペランドスタックをポップして返り値を取り出そうとしたときに、空スタックの添字エラーを起こす。</p>
<div class="fragment"><div class="line">from open(&quot;../data/dblp1K.xml&quot;) </div>
<div class="line">  go dblp/(article|inproceedings) </div>
<div class="line">  { ここにOStreamWriterが入り、次の条件式の返り値を出力する }</div>
<div class="line">  if (year &gt;= 2000) then  </div>
<div class="line">    &quot;year={{ year}} authors=[&quot;+(author)+&quot;] BIB&quot; { then側の返り値 }</div>
<div class="line">  { else側の値が未定義! }</div>
<div class="line">  end </div>
</div><!-- fragment --><p>次のように、else側で空の文字列を返すように、if-then-else文を用いると、バグは起きない。</p>
<div class="fragment"><div class="line">from open(&quot;../data/dblp1K.xml&quot;) </div>
<div class="line">  go dblp/(article|inproceedings) </div>
<div class="line">  { ここにOStreamWriterが入り、次の条件式の返り値を出力する }</div>
<div class="line">  if (year &gt;= 2000) then  </div>
<div class="line">    &quot;year={{ year}} authors=[&quot;+(author)+&quot;] BIB&quot; </div>
<div class="line">  else </div>
<div class="line">    &quot;&quot; </div>
<div class="line">  end</div>
</div><!-- fragment --><p>OStreamWriterの挿入場所を精査する必要がある。必ずしも、ステップのリターン節の根元に挿入するのが良いわけではない。かといって、リターン節のブロックの全ての末端の返り値に設定すると、値が未定義になることがある。おそらく、strictnessの問題として考えると良いだろう。</p>
<h1>200901 Tue, 21:00-27:00, 6h: Grunの清書木</h1>
<p>クエリの文法のデバグをするために、Antlr付属のGrunコマンドの出力を段下げして清書するコマンド<code>Par</code>の実装を改良した。具体的には、兄弟関係にあるノード同士の対応を強調して清書するように、オフライン版の清書器を実装する。</p>
<ul>
<li><a class="el" href="_par_8java.html">pretty/Par.java</a>: 従来のオンライン型の清書器に基づいて、構文木の構築器と、それを巡回する清書器を作成した。</li>
<li>実装は、柱文字列を保持するスタックを用いて、途中の兄弟は柱文字列をプッシュし、末尾のノードは空白の柱文字列を挿入することで、兄弟同志を垂直線で結合するように描画する。</li>
</ul>
<p>これをもちいて、クエリ言語の文法<code>query.g4</code>の条件文とブロック文の改善を行った。</p>
<ul>
<li>ステップのリターン節には、ブロックと式をおいて良いとする。</li>
<li>条件文はそれ自体で式とする。（従来は、一組の丸カッコで囲むとしていた規則を削除した。）</li>
</ul>
<h1>200830 Sun, 21:00-33:00, 12h: 型推論のバグとコメント構文解析</h1>
<p>型推論機構のバグをとった。先に抽象構文木のノードクラス<code>AstIf, AstReturn, SentList</code>を導入した際に、固定した型を用いた推論規則を使っていたために、正しく型が伝搬していなかった。当面のバグとりとして、ノードタイプごとの型推論機構を、型推論器にハンドコーディングした。</p>
<ul>
<li><a class="el" href="_ast_node_8java.html">ast/AstNode.java</a>: 型関係のメソッドを整理した。基本的に、ノードでは関数型規則<code>typing</code>のみを提供し、単一化のための型アイテムや型自体のアクセスは、<code>type/XTyping</code>にまかせることとした。各型の初期化子において、親と子の単一化関係の初期設定を行うようにした。</li>
<li>compile/XCType.java: 型推論手続き<code>recType()</code>において、ノードクラス<code>AstIf, AstReturn, SentList</code>の型推論機構を修正した。基本的に、前順巡回で先にノードの型単一化を行い、次にノードの型規則の子型（仮型）と実際の型（実型）を型単一化する。</li>
</ul>
<h2>TODO:型推論の扱いの統一化</h2>
<p>抽象構文木のノードが次のインタフェースを持つようにすれば良い。 </p><div class="fragment"><div class="line">//Base</div>
<div class="line">interface NodeNavigatable {</div>
<div class="line">  int numChildren(); </div>
<div class="line">  NodeNavigatable getChild(int i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//For XCTyping</div>
<div class="line">interface Typable extends NodeNavigatable {</div>
<div class="line">  XTypeItem getItemParent(); </div>
<div class="line">  XTypeItem getItemChild(int i); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//For XCAdapt, XCPush, XCFlat</div>
<div class="line">interface Recostructable extends NodeNavigatable {</div>
<div class="line">  void setChild(int i, Reconstructable child); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class AstNodeBranch </div>
<div class="line">  implements Typable, Reconstructable; </div>
</div><!-- fragment --><p>各ノードは、次の疑似コードで表す型項を持つ。</p>
<div class="fragment"><div class="line"><span class="comment">//条件文 if_then_else_stat </span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstIf : T {</div>
<div class="line">  0: cond : Boolean; </div>
<div class="line">  1: then : T; </div>
<div class="line">  2: else : T; </div>
<div class="line">}</div>
<div class="line"><span class="comment">//返り値付き複文 block_base</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; SentList : T {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; this.numChildren() - 1; i++)</div>
<div class="line">    this.getTypeChild(i) : Void; </div>
<div class="line">  this.getTypeChild(this.numChildren() - 1) : T; </div>
<div class="line">}</div>
<div class="line"><span class="comment">//返り分 return_stat</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstReturn : T {</div>
<div class="line">  0: expr: T; </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; RuleBase : T { }   <span class="comment">//Block := do S_1,...,S_n end </span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; StepRule : T { }   <span class="comment">//receive Path go Block </span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstVarDecl : T { } <span class="comment">//var X</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstVarUse : T { }  <span class="comment">//X?</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstAssign : T { }  <span class="comment">//X = val</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstLet : T { }     <span class="comment">//SentListに同じ</span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstAtom : T { }    <span class="comment">//Const </span></div>
<div class="line">&lt;<a class="code" href="namespacetype.html">type</a> T&gt; AstNodeBranch : T { }  <span class="comment">//SentListの斉次版</span></div>
<div class="ttc" id="anamespacetype_html"><div class="ttname"><a href="namespacetype.html">type</a></div><div class="ttdoc">値型のパッケージ</div><div class="ttdef"><b>Definition:</b> BasicTyping.java:4</div></div>
</div><!-- fragment --><h1>200817 Mon, 22:00-28:00, 6h: 抽象構文木の変換のノード自動割り当て</h1>
<p>パッケージparseでは、次のパーザーノードのTASKタイプ</p>
<ul>
<li>PLACEHOLDER：</li>
<li>GEN_TERMINAL</li>
<li>OPER_MONOIDAL</li>
<li>MODIFIER</li>
<li>SEQUENCE</li>
<li>OTHER：</li>
</ul>
<p>を用いて、構文木の変換におけるノードの生成を、手作業で実装している。 今回、Javaのリフレクションを用いて、各オリジナルのノードクラスごとに、<code>ParseTable</code>に値の三つ組を登録し、これを用いて、自動的にノード生成を行えるようにした。</p>
<p><code>MODIFIER</code>のタスクは、文法を工夫することで削除した。</p>
<p>Javaの型システムで、メタプログラミングを行った。</p>
<ul>
<li><a class="el" href="_parse_table_8java.html">ParseTable.java</a>: ptypeオブジェクトに、クラスオブジェクト名をキーとして、Function&lt;ParseTree, AstNode&gt;をもつラムダ式を値として格納する表とした。</li>
<li><a class="el" href="_ast_node_factory_8java.html">AstNodeFactory.java</a>: このうえで、ParseTableに登録したクラス名と、生成用のラムダ式を用いて、置き換え用の抽象構文木への変換を行った。</li>
</ul>
<p>Arnold, GOsling, Holmes著, プログラミング言語Java 第4版, 第16章 リフレクション, ピアソン, 2006.</p>
<h1>200816 Sun, 2:00&ndash;9:00, 7h: ジャンプ命令と条件文処理の完成</h1>
<p>仮想機械ジャンプ命令を実装し、条件文処理を完成させた。次のコンストラクタをもつ6つの命令と、ハッシュ表を使ったバックパッチの手続きを作成した。 </p><div class="fragment"><div class="line">//cmd.CommandBase.java</div>
<div class="line">CmdHALT();              //処理の終わりを表す命令。</div>
<div class="line">CmdLABEL(String label); //ラベルの命令。辞書に登録される。</div>
<div class="line">CmdJmp(int dst);       //無条件ジャンプ</div>
<div class="line">CmdJmpTRUE(int dst);   //BooleanStackの頂上値が真のとき、番地dstへ移動する。</div>
<div class="line">CmdJmpFALSE(int dst);  //BooleanStackの頂上値が偽のとき、番地dstへ移動する。</div>
<div class="line">CmdJmpZERO(int dst);   //IntegerStackの頂上値が0のとき、番地dstへ移動する。</div>
<div class="line">CmdJmpNONZERO(int dst);//IntegerStackの頂上値が0以外のとき、番地dstへ移動する。</div>
</div><!-- fragment --><p>跳び先のラベルをキーとし、ジャンプ命令自体を値とする辞書を管理する。</p>
<ul>
<li>1回目の走査：抽象構文木を深さ優先順でたどりながら、コード生成を先頭から順におこなう。もしジャンプ命令<code>jmp</code>が出てきたら、その跳び先の番地に、ラベル命令<code>cmd(label)</code>を挿入する。その時点では<code>jmp</code>の跳び先は確定しない。このとき、<code>label</code>をキーとし、命令自体<code>jmp</code>を値として、辞書に挿入する。</li>
<li>2回目の走査：バックパッチは次のように行う。番地を増加させて、先頭から末尾までコードを走査し、<code>label</code>をもつラベルオブジェクトが番地<code>i</code>で出たら、命令<code>jmp = map[label]</code>を表引きし、<code>jmp</code>の跳び先を<code>i</code>とする。</li>
</ul>
<p>最終的なコードの命令数を<code>n</code>とおくと、計算時間は<code>O(n)</code>である。</p>
<p>実装後、<code>CmdJumpFALSE</code>をもちいて<code>Where</code>節と<code>eval</code>コードの除去を行った。仮想機械からも<code>eval</code>の評価コードを除去した。はじめは、<code>CmdJumpFALSE</code>の条件が正負逆であるバグが出たが、解決後は動いているようである。速度はとくに遅くない。</p>
<p>TODOの次の2点は、完了したようだ。</p>
<ul>
<li>ast, compile: IF文の実装。<code>Where</code>節の代わりに、リターン複文で<code>AstIf</code>を用いる。</li>
<li>machine: 対応する仮想命令の実装と、仮想機械の変更。<code>eval</code>節のコードは用いない方向で修正する。とくに、back-patchを含む、仮想命令のジャンプ命令とラベル命令の実装が必要である。</li>
</ul>
<p>ためしに使うには、<code>print</code>文がほしいところだ。</p>
<h1>200816 Sun, 1:00-1:30: TODO</h1>
<p>今後の制御文の導入に必要な作業を洗い出した。</p>
<ul>
<li>ast, compile: IF文の実装。<code>Where</code>節の代わりに、リターン複文で<code>AstIf</code>を用いる。</li>
<li>machine: 対応する仮想命令の実装と、仮想機械の変更。<code>eval</code>節のコードは用いない方向で修正する。とくに、back-patchを含む、仮想命令のジャンプ命令とラベル命令の実装が必要である。</li>
<li>ast, compile: 他の制御文の実装。</li>
<li>hog-mode.el: emacsエディタの構文モードを作成する。</li>
<li>ast, parse: 文字列出力項の別表現として、文字列項に連結二項演算子<code>+</code>を導入して、実装すると良い。エディタの既存の構文モードにも対応しているので、見栄えが良い。</li>
</ul>
<p>遠い作業目標。</p>
<ul>
<li>machine: 仮想機械命令のバイトコード化。これは、制御文の導入には、必須ではない。</li>
<li>ast, parse, compile, machine: 関数呼び出しの実装。どこかでやる必要がある。</li>
</ul>
<h2>今後の方向性</h2>
<p>ブロックを構文と実行の中心に位置付けることが大事である。ここに、ステップは、パスのイベントへのプロセス化したブロックのディスパッチ実行<code>receive PATH do ... end</code>とみなされる。</p>
<p>ただし、次の点で、通常のイベント言語におけるイベントディスパッチとは異なる:</p>
<ul>
<li>一つのブロックは、<code>RefList</code>が定める一つの変数有効範囲をもつ。</li>
<li>その一方で、コードは<code>precode</code>と<code>code</code>の二つの部分に分かれており、それぞれが対となるイベント<code>STAG</code>と<code>ETAG</code>と結びつけられて呼び出される</li>
</ul>
<h2>関数呼び出しの実装。</h2>
<p>各パッケージごとに分けて、概略を記述する：</p>
<ul>
<li>ast: 関数呼び出しのノードを作成。</li>
<li>parse: 関数呼び出しの構文を追加。</li>
<li>compile: 関数呼び出しの変換機構を実装する。</li>
<li>machine: 関数呼び出しの実行時環境を実装する。</li>
</ul>
<h3>関数呼び出しの実装の詳細</h3>
<p>実行時環境での関数呼び出しは次の手順で行う。</p>
<ul>
<li>名前付きブロックには、局所変数リストの他に、長さが一致した仮引数リストと実引数リストをもたせる。</li>
<li>仮引数リストは、局所変数リスト中の変数名の並びである。便宜上、仮引数は、局所変数リストの先頭に並ぶとする。</li>
<li>実引数リストは、各仮引数に対応する実引数として、構文的に、親ブロック中で実引数として与える変数名を並べる。</li>
</ul>
<p>実行時の呼び出しでは、</p>
<ul>
<li>親ブロック<code>ridParent</code>に対応する親フレームのフレームポインタ<code>fpParent</code>を渡して、呼び出すブロック<code>rid</code>に対応する子フレーム<code>fp</code>を生成し、そのフレームポインタ<code>fp</code>を仮想機械OVMに渡して、実行させる。</li>
<li>構文スコープを用いると、返り値機構は明示的にスタック上に実装しなくて良い。代わりに、構文スコープのもとで子ブロックの末尾で、返り値を代入するための親ブロック中の目標変数へ、返り値を代入すれば良い。</li>
<li>構文スコープを用いた返り値機構の拡張として、返り値として値の組みを返せる。</li>
</ul>
<p>例として、関数呼び出しを考える。ここに、<code>t1,...,tk</code>は、funcブロックの有効範囲内の変数を用いるk個の任意の項である。 </p><div class="fragment"><div class="line">def func() { //子ブロック</div>
<div class="line">  ...; </div>
<div class="line">  return (t1,...,tk); </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{ //親ブロック</div>
<div class="line">  var x1,...,xk = func() { ...; return (t1,...,tk); }; </div>
<div class="line">} </div>
</div><!-- fragment --><p>簡単な場合として、関数定義と関数呼び出しが、同じ一つの親ブロックの中で行われる場合を考えよう。 </p><div class="fragment"><div class="line">{ //親ブロック</div>
<div class="line">  var x1,...,xk; </div>
<div class="line">  def func() { //子ブロック</div>
<div class="line">    ...; </div>
<div class="line">    x1 = t1; </div>
<div class="line">    ...</div>
<div class="line">    xk = tk;</div>
<div class="line">  }</div>
<div class="line">  call func()</div>
<div class="line">} </div>
</div><!-- fragment --><p>むずかしい場合として、関数定義のスコープが、関数呼び出しのスコープと異なるとする。 これは、名前付きお関数定義を二回以上異なる場所で再利用する場合や、モジュールの関数を用いる場合に相当する．</p>
<p>この場合は、 関数の呼び出し時に、目標変数の番地の並びを、実引数として関数のプロセスに明示的に渡し、関数の末尾にでその位置が指すメモリオブジェクトに代入することで実装できる。 </p><div class="fragment"><div class="line">{ //親ブロック</div>
<div class="line">  function func = null; </div>
<div class="line">  { //別ブロック</div>
<div class="line">    def func1(*y1,...,*yk) { </div>
<div class="line">      ...; </div>
<div class="line">      *y1 = t1; </div>
<div class="line">      ...</div>
<div class="line">      *yk = tk;</div>
<div class="line">    }</div>
<div class="line">    func = func1; </div>
<div class="line">  }</div>
<div class="line">  { //親ブロック</div>
<div class="line">    var x1,...,xk; //unique</div>
<div class="line">    call func(&amp;x1,...,&amp;xk)</div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --><p>再帰呼び出しについては、もう少し考察する必要がある。基本的に、関数呼び出しごとに新しいフレームを生成して、その中の変数を次の呼び出しに渡していけば良いはずである。</p>
<p>末尾呼び出し最適化については、一つのフレーム内のループに置き換えて、新しい子フレームを生成しないようにできそうである。</p>
<h1>200815 Sat, 13:00-19:00, 2000-23:00, 9h: ステップにおけるリターン節の複文リスト化</h1>
<p>夏期休暇中に、制御文の導入のための作業を行っている。本日までは、抽象構文木と変換レベルの作業を行った。クラス<code>AstIf</code>, <code>AstReturn</code>を導入することで、ステップの従来の<code>return</code>項を、複文のリストである<code>sents</code>と複数のリターンノードの組み合わせに置き換える作業を行った。</p>
<ul>
<li><a class="el" href="_ast_if_8java.html" title="190115: Created by arim@ist.hokudai.ac.jp">ast/AstIf.java</a>: ダミーとして条件文を作成した。</li>
<li><a class="el" href="_step_8java.html" title="190113: Renamed from StepExpr.java 180722: Separated from AstNode.java 180228: Modified by arim@ist....">ast/Step.java</a>: 次の修正を行った：<ul>
<li>文リストを保持する<code>sents</code>節を追加した。これに伴い、getter/setterを実装した。<code>addSents(AstNode node)</code>の作成が多少面倒。</li>
<li>ステップの<code>sents</code>節が含むリターン命令の返り値型の最小上界を保持する<code>RetList</code>クラスを作成し、ステップに対応する<code>retList</code>フィールドを新設した。</li>
<li>リターン節<code>ret_</code>から<code>Step.sents</code>フィールドと<code>AstReturn</code>クラスへの分解に伴い、書き込みオブジェクトを保持するフィールド<code>AstDataWriter Writer_</code>と、getter/setterを追加した。</li>
</ul>
</li>
<li><a class="el" href="_ast_return_8java.html" title="190115: Created by arim@ist.hokudai.ac.jp">ast/AstReturn.java</a>: リターン命令のクラス<code>AstReturn</code>を作成した。子の項ノードを保持するフィールド<code>AstNode sent_</code>と、getter/setterを追加した。</li>
<li>compile/XCType.java: リターン命令の返り値型の型推論を実装した。<ul>
<li>Refactoringとして、従来の各型に対する処理を分離して、ノードクラスごとに異なる型推論をするようにした。この変更は手を要したが、コードの見通しがよくなった。</li>
<li><code>Step.sents</code>フィールドの複文と、その中の<code>AstReturn</code>命令を正しく型付けできるように修正した。このため、リターン命令の返り値型全体の抽象型<code>Step.retList</code>の管理機構を実装した。これは、<code>addReturn(AstReturn ret)</code>によりリターン命令を追加するごとに、それらの返り値型の単一化を行うデータ構造である。ただし、リターン命令自体は格納しない。</li>
<li>TODOとして、将来は、各ノードクラスに、詳細な親子の型伝搬の指定を行えるようにして、<code>XCType</code>クラスの記述を簡素化し、処理を一様化する必要がある。</li>
</ul>
</li>
<li><a class="el" href="_x_c_adapt_8java.html">compile/XCAdapt.java</a>: 返り値省略時のテキスト値取得ノード<code>AstDataReader.ReaderGetText</code>の追加処理を、ステップノードからリターン命令へ移動して、実装した。強制型変換のノード<code>AstConverter</code>が正しく挿入されないバグを解決した。</li>
<li><a class="el" href="_x_c_push_8java.html">compile/XCPush.java</a>: 共通変数による返り値処理を、ステップノードからリターン命令へ移動して、実装した。</li>
<li>parse/query.g4, AstParse.java: クラス<code>AstIf</code>, <code>AstReturn</code>関連の構文解析部を追加した。</li>
</ul>
<p>従来の<code>return</code>項から、複文のリストとリターン命令を分離する変更はかなり時間を要したが、全体として、コンパイル系のコードの見通しがよくなった。また、このリターン命令の分離と複数化は、If文や、while文、for文、switch文などの複雑な制御文の導入にあたり、前段階で不可欠な作業である。</p>
<h2>ステップの実行部の複文リスト化</h2>
<p>これまで、旧ステップは<code>where</code>節と<code>return</code>項をフィールドとしてもっていた。 </p><div class="fragment"><div class="line">step = path [ cond ] return term</div>
</div><!-- fragment --><p>これに対して、条件文を導入することで、<code>where</code>節を廃止して、<code>return</code>項を後処理のコード<code>sents</code>として置き換えて、ステップを一般化することを目標として作業を行った。 </p><div class="fragment"><div class="line">step = path if cond then sents</div>
</div><!-- fragment --><p> これにより、仮想機械<code>XMachine</code>のステップ処理が単純化することができる。</p>
<h2>ステップの返り値の型の推定</h2>
<p>上記の作業にともない、ステップの後処理コード<code>sents</code>は、複数の<code>return</code>文を含み得るので、型推論が必要である。これは、条件文や繰り返し文の中の<code>return</code>文の出現による。そこで、ステップが含む全ての<code>return</code>文を収集し、それらの返り値の型の最小上界を求めて、ステップの返り値の型を確定する。</p>
<h1>200814 Fri, 11:00-13:30: ステップオブジェクトの再設計</h1>
<p>Xscan2に移行に際して、ブロックとステップの位置付けの整理をした。</p>
<p>Xscan は、構文的スコープ（lexical scope）をもつ任意深さの入れ子ブロック構造を許すプログラミング言語である。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter">構文解析（静的）   </th><th class="markdownTableHeadCenter">実行環境（動的）    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">ID   </td><td class="markdownTableBodyCenter">rid   </td><td class="markdownTableBodyCenter">fid    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">表   </td><td class="markdownTableBodyCenter">RefList   </td><td class="markdownTableBodyCenter">List(MemCell)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">構造   </td><td class="markdownTableBodyCenter">Block   </td><td class="markdownTableBodyCenter">Frame   </td></tr>
</table>
<p>ソースコードにおけるブロックとステップのオブジェクトは次のようになる。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Phase   </th><th class="markdownTableHeadCenter">構文解析   </th><th class="markdownTableHeadCenter">実行環境    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Block   </td><td class="markdownTableBodyCenter">AstBlock   </td><td class="markdownTableBodyCenter">BlockRule    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">Step   </td><td class="markdownTableBodyCenter">AstStep   </td><td class="markdownTableBodyCenter">StepRule   </td></tr>
</table>
<h1>200812 Thu, 00:30-01:00, TODO: モジュール機構の設計</h1>
<p>**データ処理とプログラミングのエコシステム**を考えると、外部ライブラリの導入のためのモジュール機構は必要である。利用者は、xscanシステムの特性を十分理解しているとは仮定できないので（scikitlearnが好例）、ある程度理解した日常的使用者が高度な使用法をモジュールの形で提供することが望ましい。モジュール機構は、その際に、名前の衝突を防ぐ名前空間と、手続きのカプセル化を提供するものである。</p>
<p>Xscanシステムは、関数型言語的な、**任意入れ子が可能な階層的で構文的な有効範囲規則**（lexical scope rule）をもっている。これを利用すると、モジュールが簡単に実装できるのではないか。**基本的な方針**として、一つのファイルをなすモジュール<code>m</code>の全体を、一つの大きなブロックとして扱い、関数名の有効範囲とする。これにより、通常はモジュールの外側から、モジュール内の関数<code>func</code>は見えず、隠蔽される。これに対して、<code>m.func</code>のような完全修飾名を与えることで、モジュールの外部からアクセスができる。さらに、<code>#include m</code>のようなモジュールの包含指示子を提供することで、モジュールを外部からのアクセスに対して開くことができ、モジュール内の関数を<code>func</code>のように修飾子を省略して使える。</p>
<p>この**モジュール機構の最も簡単な実現方法**は、変数の記号表に加えて、関数の記号表をシステムで提供し、静的に宣言された関数は、記号表を通じてアクセス（呼び出し）することだろう。動的に宣言された関数は、メモリ上の最外フレーム上のレコードにポインタ（ルールID）を登録し、呼び出すことだろう。</p>
<p>ヒープ上のフレームを実現すると、これと、任意入れ子のレキシカルスコープを組み合わせて、ヒープ上のオブジェクトまたは、構造体を実現できる。</p>
<p>このあたりの言語設計と実装は、javascriptを参考にするのが良いのではないか。Elixir言語のように内部状態をもつオブジェクトは回避し、関数のみを提供するモジュールにすると良いかもしれない。オブジェクトの代わりに、ホスト言語からタプルとハッシュを提供すれば、手続き的または関数的なプログラミングには困らないだろう。</p>
<p>あるいは、動的言語として、タグ付きのデータを統一的に使うこととして、関数ポインタ（われわれの場合は単にルールIDを表す整数<code>rid</code>である。</p>
<p>それにしても、意図しない使用法に対しても、頑健なプログラミングは難しいものである。基本設計をおろそかにせず、原則を決めて、それにそって、堅固にコーディングする必要がある。</p>
<h1>200812 Wed, 21:00-25:00, Bug fix and refactor</h1>
<p>先日実装した<code>ScanFrom</code>サブクエリのコード変換の不具合を修正し、コードをリファクタリングした。</p>
<ul>
<li><a class="el" href="_x_c_adapt_8java.html">compile/XCAdapt.java</a>: これは、<code>ScanFrom</code>サブクエリがもつ照合ルール（target rule）を、クラス<code>XCAdapt</code>において、文書の根ラベル<code>$DOC</code>をタグにもつトップレベルのルールでラップしていたが、型変換と記号表の親子関係の管理が面倒であり、関連したバグが生じていた。そこで、この処理を変換の前処理モジュールである<code>XCTyping</code>に移した。</li>
<li>compile/XCType.java: リファクタリングを行い、このクラスが推論した型と記号表の親子関係の付与するように統一した。また、</li>
<li>ast/RuleBase.java: 記号表<code>RefList</code>の管理を本クラスに集約した。このクラスは、ブロックの構文的スコープを担当するクラスとなった。名称は、これのクラスを<code>BasicBlock</code>として、そのサブクラスを<code>StepRule</code>と<code>BlockRule</code>とすべきだろう。記号表の名前も、<code>RefTable</code>か<code>VarTable</code>とすべきかもしれない。</li>
<li>根ステップルールを生成するファクトリ手続きを、クラス<code>StepRule</code>に付与した。クラス<code>Step</code>のオブジェクトは、元々XPathのステップを実現するためのもので、その意味論（Wadlerのもの）として述語が必須だったが、現在のXscanシステムと言語では、今後、述語は実行部の条件文として実装されるので、クラス<code>Step</code>から述語機能を除去して、実行系をコードを実行するだけのシンプルものにすべきだろう。</li>
<li>TODO：　次は、条件ジャンプの仮想命令をOVM上に実装し、パス照合の基本機構でなく、言語の構文として条件文を実現する。これにより、ストリーム処理言語として、よりシンプルで効率良い実装が可能になる。実装には、ジャンプ先のラベルのback-patchの仕組みをおさらいしておく必要がある。これは、コード生成後に、線形走査とラベルをキーとする辞書を組み合わせるのが簡単で、線形計算量に抑えられそうである。</li>
</ul>
<p>トップレベルのプログラムに複文を許したために生じたバグを修正した。</p>
<ul>
<li>これは、プログラムに、出力のテキストテンプレートをもつ<code>ScanFrom</code>サブクエリを二つ以上並べると、一番目の出力テンプレート文字列に、二番目のサブクエリが含まれてしまうバグが生じた。</li>
<li>原因は、Antlrの出力テンプレートが用いている形態素定義が不適切で、非終端記号<code>MSTRQQ</code>の本体が<code>DQ</code>（二重引用符）を排除できてなかったために、正規表現の貪欲マッチによって、自身の終端の二重引用符を超えて、次のクエリ中の<code>DQ</code>まで読み込んでしまうためであった。</li>
<li>parse/query.g4: 上記の修正を行った。</li>
</ul>
<h1>200811 Tue, 24:00-28:00, Issues</h1>
<p>Githubのasax03レポジトリにおいて、IssuesとMilestonesを記載した。次のMilesstonesを設定した：</p>
<ul>
<li>2020.05.15 due: basic path processing layer。完了済み。</li>
<li>2020.08.31 due: basic stream programming layer。現在、完了中。</li>
<li>2020.09.30 due: control programming layer。次の目標。</li>
<li>2020.12.31 due: composite stream processing layer</li>
<li>2021.03.31 due: 1st public release layer。配布のため、ユースケースや説明書も含んだ コードと情報を公開する。</li>
<li>2022.03.31 due: future of xscan。期限なしの機能追加リスト。</li>
</ul>
<h1>200808 Mon, 22:00-26:00, 200810 Mon/Holiday 04:00-9:36: クエリ言語へのスキャンループ命令の組み込み。</h1>
<p>7月下旬から行っていた入力ストリーム周りとイベントループの再構築をひととおり動くようにした。クエリ言語に、つぎのような<code>ScanFrom</code>構文を導入した。これに対応して、文法と、ASTノード、実行機械、仮想命令を導入した。</p>
<ul>
<li>parse.query.g4: Ruby風の<code>ScanFrom</code>構文要素を導入した。 <div class="fragment"><div class="line">query : top_states ;</div>
<div class="line">top_states</div>
<div class="line">    : //empty </div>
<div class="line">    | a0=statement_or_decl_or_scan &#39;;&#39; ( a0=statement_or_decl_or_scan &#39;;&#39; )*  ;</div>
<div class="line">statement_or_decl_or_scan : statement | decl | scan  ;</div>
<div class="line">scan : FROM a0=source DO_OR_GO a1=step ;</div>
<div class="line">source : stdin | fileopen ;</div>
<div class="line">fileopen : OPEN LPAR ( t0=DQSTRING | t0=SQSTRING ) RPAR ;</div>
<div class="line">stdin    : t0=&#39;stdin&#39; | t0=&#39;STDIN&#39; | t0=&#39;-&#39; ;</div>
<div class="line">FROM : &#39;from&#39; ;  TO   : &#39;to&#39; ;  OPEN : &#39;open&#39; ;</div>
<div class="line">DO_OR_GO  : DO | &#39;go&#39; ; DO  : &#39;do&#39; ; END  : &#39;end&#39; ; </div>
</div><!-- fragment --></li>
<li>ast.ScanFrom.java: クラス<code>ast.ScanFrom</code>を導入し、その子要素として用いる<code><a class="el" href="classast_1_1_ast_source.html" title="入力ストリームを表すノードのクラス">ast.AstSource</a></code>と部分クラス<code>AstInsConst</code>と<code>AstInsOpen</code>を導入した。それぞれ、stdinおよびファイルオープンに対応する。</li>
<li>machine.XMachine.java: 手続き<code>void scanFromSource(InputStream ins, int rootID)</code>を追加した。これは、根クエリ<code>rootID</code>のもとで、与えられた入力ストリームを走査する。</li>
<li>compile.XCompiler.java: コンパイル副手続きに上記の構文要素を追加した。また、<code>Step</code>に加えて、<code>BlockRule</code>も構文要素として受け付けるようにした。</li>
<li>Match.java: 上記の更新した部品を組み込んだ。</li>
</ul>
<p>現在、test.dblpでのテストは動いているようだ。</p>
<h2>TODO</h2>
<ul>
<li>変数レコードの初期化と割付が正しく行われるかテストすること。</li>
<li>とくに、トップレベルに、任意このファイル操作と、変数の宣言、代入命令を繰り返した列で、バグが生じることがある。正しく動作するかをテストする必要がある。</li>
<li>名前なしブロックの呼び出しは正しく動いているようだ。関数と名前付きブロックの呼び出し機構を設計して、動かすこと。</li>
<li>それがうまく動いたら、制御構造もいれたい。</li>
<li>変数の構文有効範囲（lexical scope）をもつ言語として、素直な設計にすること。</li>
</ul>
<p>つぎのようなプログラムが動いている。</p>
<div class="fragment"><div class="line">var x,y; </div>
<div class="line">x = 10; </div>
<div class="line">y = 20; </div>
<div class="line">from open(&quot;../data/dblp1K.xml&quot;)</div>
<div class="line">do</div>
<div class="line">  dblp/(article|inproceedings) [ title =~ &quot;Data&quot; and year &gt;= 1990 ]</div>
<div class="line">  return</div>
<div class="line">  &quot;{{$nm}}:{{$nr}}: TY[{{ $label }}] PY[{{year}}] AU[{{ </div>
<div class="line">    author return &quot;{{ text() }}; &quot; </div>
<div class="line">  }}] TI[{{title}}]&quot;  ; </div>
</div><!-- fragment --><h1>200719 Sun, 8:00-10:00, 18:00-: メモリのリファクタリング</h1>
<p>フレームスタックメモリ周りをリファクタリングした。 オブジェクトの初期化手続きのインタフェース<code>Resetter</code>を導入し、クラス<code>AutoStack</code>から、インタフェース<code>Container</code>への依存性を除去位した。その上で、クラス<code>Container</code>を拡充した。また、asax全体から、クラス<code>ContainerManager</code>を除去した。</p>
<ul>
<li>frame/Container.java: クラス<code>Container</code></li>
<li>util/Resetter.java: インタフェース<code>Resetter</code>を導入した。</li>
<li>util/ContainerManager.java: クラスを除去した。</li>
<li><a class="el" href="_auto_stack_8java.html">util/AutoStack.java</a>, <a class="el" href="_frame_stack_uni_8java.html">frame/FrameStackUni.java</a>: ContainerManagerのコードを除去した。</li>
</ul>
<h1>200703 Sat, 21:30-23:30:</h1>
<p>Makeが一回でとおらないバグを，パッケージ間の依存性を除去して改善した．</p>
<ul>
<li>AstAtom.java: クラスにstatic なReportオブジェクトを持たせて，手続き<code>static void setReporter(Report repo)</code>を用いて，外部から<code>XMachine.repo</code>を注入し，サブクラスがこれを用いる方式とした．これにより，AstNodeのサブクラスからはXMachineをみなくてよくなった．</li>
<li>machine, cmd: 仮想機械語関係のコードを，パッケージ<code>machine</code>から<code>cmd</code>へ移した．</li>
<li>parse/query.g4: タグ名にハイフン<code>-</code>を使えるようにした．</li>
</ul>
<h1>200630 Tue, 05:00-06:00, 1h: コンパイルと動的型チェックのバグ</h1>
<h2>TODO</h2>
<p>出力ストリーム参照のクラス<code>OSRef</code>は使われていないのでは？　あるいは，一般の参照と統合すべきでは？</p>
<h2>TODO</h2>
<p>こういうgrepの拡張言語をつくったら便利では？</p>
<div class="fragment"><div class="line">$ history </div>
<div class="line">  537  git add -vn .</div>
<div class="line">  538  git add -v .</div>
<div class="line">  539  git commit -m &quot;feat:return&quot;</div>
<div class="line">  540  git push</div>
<div class="line">  541  s</div>
<div class="line">  542  make opendoc</div>
<div class="line">  543  ag OSRef .</div>
<div class="line">  544  h</div>
<div class="line">=&gt; </div>
<div class="line">$ history | sawk &#39; </div>
<div class="line">match </div>
<div class="line">(com1=ADD() . com2=COMM() . com3=PUSH()) </div>
<div class="line">where </div>
<div class="line"> def ADD()  match $1 =~ /([0-9]+)/ and $2 =~ /^git add / do return this</div>
<div class="line"> def COMM() match $1 =~ /([0-9]+)/ and $2 =~ /^git commit / do return this</div>
<div class="line"> def PUSH() match $1 =~ /([0-9]+)/ and $2 =~ /^git push / do return this</div>
<div class="line">return &quot;!&quot;+com1.$1 + &quot;; &quot; + &quot;!&quot;+com2.$1 + &quot;; &quot; + &quot;!&quot;+com3.$1 + &quot;; &quot; </div>
<div class="line">&#39;</div>
<div class="line">=&gt; </div>
<div class="line">!538; !539; !540;</div>
</div><!-- fragment --><p>ここに，言語の水平パターンの糖衣構文はつぎを想定する：</p>
<ul>
<li>連続部分系列（n-gram）: <code>(A . B . C) := (s[t] == A &amp;&amp; s[t+1] == B &amp;&amp; s[t+2]==C)</code></li>
<li>非連続部分系列（sparse n-gram）: <code>(A , B , C) = (A .* B .* C) := for some i &gt;= 0, j &gt;= with (s[t] == A &amp;&amp; s[t+i] == B &amp;&amp; s[t+i+j]==C)</code></li>
</ul>
<p>これは，水平正規表現を用いたXscanの拡張とみなせる．</p>
<h2>簡易構文</h2>
<p>クエリにおいて，キーワード<code>return</code>の代わりに<code>=&gt;</code>を使えるようにした．これにより，リターン文</p>
<div class="fragment"><div class="line">return &quot;yr={{ year return &quot;{{ elem() }}&quot; }} au={{ author return &quot;{{ elem() }}&quot; }}&quot;</div>
</div><!-- fragment --><p>は，より直感的な構文</p>
<div class="fragment"><div class="line">return &quot;yr={{ year =&gt; elem() }} au={{ author =&gt; elem() }}&quot;</div>
</div><!-- fragment --><p>を用いて書けるようになった．文字列結合演算子<code>+</code>を用いて，</p>
<div class="fragment"><div class="line">return &quot;yr=&quot; + (year =&gt; elem()) + &quot; au=&quot; + (author =&gt; elem()) +&quot;&quot;</div>
</div><!-- fragment --><p>と書いても良いかもしれない．「かっこ」の入れ子が浅い方がよみやすいかもしれない．</p>
<h2>バグ報告</h2>
<p>仮想機械語命令のコンパイルと実行時に，動的な型不整合のバグがある． 次の文字列命令中での変数読み出しを用いたクエリにおいて，</p>
<div class="fragment"><div class="line">$ echo &#39;var A; A = 1; dblp/inproceedings [ A = (A? + 1); true ] </div>
<div class="line">return &quot;###{{ A? }}### :{{ $nm }} yr={{ year =&gt; elem() }} au={{ author =&gt; elem() }}&quot; ; &#39; | time javaexec Match -i ../data/dblp1K.xml </div>
<div class="line"> </div>
<div class="line">###&lt;year&gt;1998&lt;/year&gt;### :0 yr=&lt;year&gt;1998&lt;/year&gt; au=&lt;author&gt;Emil Sekerinski&lt;/author&gt;</div>
<div class="line">###&lt;year&gt;1998&lt;/year&gt;### :1 yr=&lt;year&gt;1998&lt;/year&gt; au=&lt;author&gt;Patrick Behm&lt;/author&gt;&lt;author&gt;Lilian Burdy&lt;/author&gt;&lt;author&gt;Jean-Marc Meynadier&lt;/author&gt;</div>
</div><!-- fragment --><p>上記で，整数型の変数<code>A</code>の出力に関して，誤って年<code>year</code>の値<code>elem()</code>の変数値が使われて出力するというバグが生じている．</p>
<p>これは，次の理由による．上記のクエリで，<code>dblp/inproceedings</code>タグのサブクエリのリターン節の文字列出力命令<code>###{{ A? }}###</code>は，次の機械語コードにコンパイルされる．</p>
<div class="fragment"><div class="line">| | | post: [</div>
<div class="line">| | |   0:CmdStrConst(&#39;###&#39;),</div>
<div class="line">| | |   1:CmdStrLoad(var4:Integer(&#39;A&#39;)),</div>
<div class="line">| | |   2:CmdStrAdd(+),</div>
</div><!-- fragment --><p>ここで，整数型の参照&lsquo;var4:Integer('A&rsquo;)<code>を，文字列型の命令</code>CmdStrLoad(var4:Integer('A'))<code>で文字列形の参照として使っているのはコンパイルの誤りである．これにより，整数型の参照</code>var4:Integer('A')`の即値が整数型のデータオブジェクトスタックの番地として用いるべきところを，誤った型である文字列形の値オブジェクトスタックの番地として読み出してしまっているため，誤った値を出力してしまっている．</p>
<p>これは，コンパイル時の型整合機構の誤りに加えて，実行時の動的型チェックが欠落していることからおきるバグであるので，両方を修正する必要がある．少なくとも，コンパイル系に依存せず，実行系は誤った型のアクセスに対して，エラーを検出してpanic状態に移行すべきである．</p>
<h1>200628 Sun, 22:00-29:00, 7h: 変数機構の実装</h1>
<p>変数機構を実装した．</p>
<ul>
<li>変数宣言．これは，ブロックの中での変数宣言<code>var X</code>である．</li>
<li>変数代入．これは，変数の左辺値としての使用<code>X = ...</code>である．</li>
<li>変数利用．これは，変数の右辺値としての使用<code>X?</code>である．</li>
</ul>
<p>そのために，変数の構文的スコープ規則と，型推論のための型単一化の仕組みが必要である．そのために，次を作成した．</p>
<ul>
<li>machine/RefImpl.java: 単一化可能な型アイテム<code>TypeItem type</code>と，大域的な変数番号<code>int vid</code>，名前文字列<code>String name</code>の三つのフィールドをもつ参照オブジェクトである．以前は値型<code>XType type</code>だったが，これを型アイテムに変えた．</li>
<li>machine/StepProgram.java: 内部クラスとして，プログラム中のすべての変数を保持するリストである<code>GlobalRefList</code>を作成した．これをStepProgramのメンバー<code>gRefList</code>として，プログラム全体で一つだけ保持する．大域的な新しい変数番号は，これを通してのみ生成する．</li>
<li><a class="el" href="_ref_list_8java.html">machine/RefList.java</a>: 各ステップまたはブロックは，変数参照の記号表<code>RefList</code>を保持する．次のメソッドをもつ：<ul>
<li>コンストラクタは，大域変数リストを保持するプログラムと親となる記号表を保持する親ブロックを引数として受け取り，ブロックチェーンを実現する．</li>
<li>大域変数リストから得た変数番号からRefを作成し，それをブロックの記号表へ登録する<code>Ref register(XType type, String name)</code>．</li>
<li>ブロック内に出現する変数名文字列<code>String name</code>から，構文的なブロックチェーンをさかのぼって変数参照の宣言ブロックをみつける<code>Ref fetch(String name)</code>の二つの手続きをもつ．</li>
</ul>
</li>
</ul>
<p>構文での変数の使用<code>X?</code>は， 名前<code>X</code>に修飾子<code>?</code>を続ける．これは，パスやタグと，変数を区別するために必要である．ただし煩雑なので，将来的には通常の名前のみで変数の使用を示せるようにしたい．パスを変数から区別する記法があれば良いだろう．例えば，&lsquo;'title&rsquo;<code>や</code>.title`が例である．</p>
<p>よりパワフルな型推論ができるようになったので，<code>String</code>, <code>Integer</code>, <code>Boolean</code>の型の任意の項を，WhereとReturn節で使えるようにした．将来は任意の場所で型変換を用いて使えるように整備する．</p>
<h2>クエリの例</h2>
<p>次のクエリでは，変数XとYが<code>Integer</code>型と正しく推論される．</p>
<div class="fragment"><div class="line">make all &amp;&amp; echo &#39;var X; var Y; X = 100; Y = X?; dblp/inproceedings [ (Y? + 20)  &lt;= 100 ] return &quot;tag={{ $nm }}: title={{ title }}&quot; ; &#39; | time  javaexec Match -xeasax -t1 -i ../data/dblp1K.xml </div>
</div><!-- fragment --><p>次のクエリでは，変数Xが<code>String</code>型と正しく推論される．</p>
<div class="fragment"><div class="line">$ make all &amp;&amp; echo &#39;var X; dblp/inproceedings [ X = year; true ] return &quot;match:{{ $nm }} yr={{ X? }}\n&quot; ; &#39;  | time  javaexec Match -xeasax -ea -t1 -i ../data/dblp1K.xml</div>
</div><!-- fragment --><p>階層的な宣言/書き込み/読み込みも問題ない．</p>
<p>次は，増分のクエリである．問題なくコンパイルされる．</p>
<div class="fragment"><div class="line">&#39;var A; A = 1; dblp/inproceedings [ A = (A? + 1); true ] return &quot;###{{ A? }}### match:{{ $nm }} yr={{ year }} au={{ au }}\n&quot; ; &#39;</div>
<div class="line">=&gt; </div>
<div class="line">| | | eval: [</div>
<div class="line">| | |   0:CmdIntLoad(var4(A):Integer),</div>
<div class="line">| | |   1:CmdIntConst(1),</div>
<div class="line">| | |   2:CmdIntOpr(+),</div>
<div class="line">| | |   3:CmdIntStore(var4(A):Integer),</div>
<div class="line">| | |   4:CmdBoolConst(true)</div>
<div class="line">| | | ],</div>
</div><!-- fragment --><h1>200627 Sat, 15:30-17:30, 21:30-27:30, 8h:</h1>
<p>週末に，複文からなるブロック<code>文_1; ...; 文_{n-1}; 項_n</code>を導入して，クエリの構文を拡張した．主な目的は，明示的な変数宣言<code>var x</code>と変数代入<code>x = term</code>の形の文（sentence）の導入である．ブロックが導入できると，ruby言語のように，種々の制御構文や関数定義をブロックを中心として扱えるようになるので，重要である．</p>
<ul>
<li>parse/query.g4: ステップの述語と項の代わりに，複文からなるブロック<code>文_1; ...; 文_{n-1}; 項_n</code>を許すように構文を拡張した．これに合わせて，文の構文要素<code>Sent</code>と，各種の型の項と，型によらない項の構文要素を整備した．</li>
<li><a class="el" href="_ast_parser_8java.html">parse/AstParser.java</a>, <a class="el" href="_ast_node_factory_8java.html">AstNodeFactory.java</a>: query.g4の文法の修正に合わせて，構文解析を行うように更新した．</li>
<li>ast/AstArrow.java, AstList.java: 代入命令のクラス<code>AstArrow</code>を作成した．合わせて，型による汎的なコード生成のツールを整備した．さらに，<code>AstList</code>のサブクラス<code>SentList</code>を作成した．</li>
<li>machine.CommandFactory.java: クラスCommandFactoryの内容が，へ移動した．<code>AstDataReader</code>と<code>AstDataWriter</code>の型スイッチによる生成のファクトリクラスCommandFactoryを作成した．</li>
<li>ast.AstFactory.java: 旧<code>CommandFactory</code>からのコードを集めて，型スイッチに基づくAstNodeの生成のためのファクトリクラス<code>AstFactory</code>を作成した．</li>
</ul>
<h1>200622 Mon: TODO</h1>
<p>ここで、フィルタや整列などの実用的な構造テキスト処理のための機能を実装すると良い。 下記のような直列化変換と逆変換を実装すると良い。ソートに使えるはずである。</p>
<div class="fragment"><div class="line">cat dtree.log | tr &#39;\n&#39; &#39; &#39; </div>
<div class="line">| sed &#39;s/\&zwj;([21][0-9][0-9][0-9]:\&zwj;)/####\1/g&#39; </div>
<div class="line">| sed -e &#39;s/####/\n/g&#39; &#39;\n&#39;</div>
</div><!-- fragment --><p>実用的には、パス正規表現の宣言<code>(article|inproceedings)</code>とワイルドカード<code>*</code>を実装すると良い。</p>
<h1>200621 Sun, 21:00-27:30 走査器Asaxのリファクタリングと要素テキスト出力の実装</h1>
<p>昼に運転免許の更新に行った。走査器に、要素の生テキストの出力機構を組み込んだ。そのために、走査器のリファクタリングと再実装をおこなった。</p>
<ul>
<li>event.Env.java: 走査器のパラメータの環境<code>Env</code>型の実装を、文字列値のハッシュから、整数値と文字列値の固定レコードに変更した。</li>
<li>event.EventReaderBase.java: machine.XMachine.java: 環境スタック<code>ES</code>を<code>AutoStack&lt;Env&gt;</code>型のオブジェクトに変更した。これにともない、走査器のリファクタリングを行なった。</li>
<li><a class="el" href="_asax_event_reader_8java.html">event/asax/AsaxEventReader.java</a>: 要素の開始タグと終了タグの開始と終了の位置を、環境に記録するようにした。STAGとETAGイベントの出力時に、これらの情報を環境から取り出し、イベントのposフィールドに格納して返すことにした。</li>
<li>machine.XMachine.java: 仮想機械に、上記の情報を返す関数<code>int curPos()</code>と<code>int getSubstring(int spos, int epos)</code>を実装した。要素のテキスト部分列の開始と終了の位置<code>spos</code>と<code>epos</code>は、スキャナ内で関数<code>curPos()</code>を通じて取得されたものである。これらの関数は、<code>interface Context</code>を通じて、コマンド側に公開する。</li>
<li>event.EventReaderBase.java: 走査器のリファクタリングを行なった。具体的には、execXXXXグループの手続きを抹消して、直接、環境スタック<code>ES</code>と、その<code>AutoStack&lt;Env&gt;</code>型の演算を用いることにして、簡素化した。</li>
<li>io.PooledInputStream.java: 関数<code>int curPos()</code>と<code>int getSubstring(int spos, int epos)</code>を、インタフェース<code><a class="el" href="interfaceio_1_1_input_scannable.html" title="部分文字列の抽出が可能な入力文字ストリームのインタフェース.">io.InputScannable</a></code>と<code>io.PooledInputStream.java</code>に実装した。</li>
</ul>
<p>リファクタリングにおいて、asaxはほとんど修正が不要だった。これは、前回のリファクタリングにより、構造テキストの共通部分は<code>EventReaderBase.java</code>に集約され、XMLタグの構文解析のロジックのみが<code><a class="el" href="_asax_event_reader_8java.html">AsaxEventReader.java</a></code>に書き込まれていたためである。eventプログラムの構造は、だいたいよいのではないか。</p>
<p>DBLPデータ上での実験では、通常のタグ要素と属性要素の両方とも出力されている。</p>
<div class="fragment"><div class="line">$ echo &#39;dblp/inproceedings [ ] return &quot;nm={{$nm}}:[{{ elem() }}]\n&quot; ; &#39; | time  javaexec Match  -i ../data/dblp1K.xml</div>
<div class="line"> </div>
<div class="line">nm=0:[&lt;inproceedings key=&quot;conf/b/Sekerinski98&quot;&gt;</div>
<div class="line">&lt;author&gt;Emil Sekerinski&lt;/author&gt;</div>
<div class="line">&lt;title&gt;Graphical Design of Reactive Systems.&lt;/title&gt;</div>
<div class="line">&lt;pages&gt;182-197&lt;/pages&gt;</div>
<div class="line">&lt;year&gt;1998&lt;/year&gt;</div>
<div class="line">&lt;crossref&gt;conf/b/1998&lt;/crossref&gt;</div>
<div class="line">&lt;booktitle&gt;B&lt;/booktitle&gt;</div>
<div class="line">&lt;ee&gt;http://link.springer.de/link/service/series/0558/bibs/1393/13930182.htm&lt;/ee&gt;</div>
<div class="line">&lt;url&gt;db/conf/b/b1998.html#Sekerinski98&lt;/url&gt;</div>
<div class="line">&lt;/inproceedings&gt;]</div>
<div class="line">（中略）</div>
<div class="line"> </div>
<div class="line">$ echo &#39;dblp/inproceedings/@key [ ] return &quot;nm={{$nm}}:[{{ elem() }}]\n&quot; ; &#39; | time  javaexec Match  -i ../data/dblp1K.xml</div>
<div class="line">（中略）</div>
<div class="line">nm=812:[key=&quot;conf/ai/LingZ98&quot;]</div>
<div class="line">nm=813:[key=&quot;conf/ai/LiuCZ98&quot;]</div>
<div class="line">nm=814:[key=&quot;conf/ai/PlamondonK02&quot;]</div>
</div><!-- fragment --><p>計算時間は、DBLPの全データについて、<code>inproceedings</code>の各エントリの要素テキストを出力しても、99秒前後であり、要素テキストの出力が速度低下はもたらしていないようだ。 現在、XPP3スキャナーよりも、ASAXスキャナーの方が高機能で、速度も遅くないので、asaxをデフォールトのスキャナーにした。オプション<code>-s asax|xpp</code>で切り替えられる。</p>
<h2>パラメータの環境スタックの実装変更</h2>
<p>従来、走査器の変数環境Envを、文字列型のハッシュ表で実装していたが型変換の計算時間のオーバーヘッドが大きいのが問題だった。これを基本型のフィールドをもつ構造体で再実装した.</p>
<ul>
<li>event.Env.java: 各型のフィールドを保持し、演算<code>clear()</code>をもつ構造体で実装した。</li>
<li>event.EventReaderBase.java: 環境スタック<code>ES</code>の実装として、EnvStackクラスを廃止し、<code><a class="el" href="classutil_1_1_auto_stack.html" title="再利用可能な型Sのオブジェクトを要素に持つスタックの実装.">util.AutoStack</a>&lt;Env&gt;</code>型の自動スタックを使うよう変更した。</li>
</ul>
<p>走査器asaxの以前の実装と、今回の実装変更を比較した。結果として、DBLPデータ(2.9GB)の走査時間が、約300secから約100secと1/3に減少した。メモリ設定は、 -Xms10m -Xmx20mとした。メモリ使用量は、従来はmem=47.1MB程度で、今回の実装はmem=40.1MB程度で、ほとんど変わらないと見える。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">dblp.xml (2.9GB)   </th><th class="markdownTableHeadRight">wcコマンド   </th><th class="markdownTableHeadRight">Xscan /w Asax old   </th><th class="markdownTableHeadRight">Xscan /w Asax new    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">計算時間 (sec)   </td><td class="markdownTableBodyRight">12.3sec   </td><td class="markdownTableBodyRight">352sec   </td><td class="markdownTableBodyRight">115.1sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">計算時間 (min)   </td><td class="markdownTableBodyRight">0.2min   </td><td class="markdownTableBodyRight">5.9min   </td><td class="markdownTableBodyRight">1.9min    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">速度 (mb/sec)   </td><td class="markdownTableBodyRight">236mb/sec   </td><td class="markdownTableBodyRight">8.24mb/sec   </td><td class="markdownTableBodyRight">25.2mb/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">メモリ概算   </td><td class="markdownTableBodyRight">-   </td><td class="markdownTableBodyRight">47mb   </td><td class="markdownTableBodyRight">41mb   </td></tr>
</table>
<div class="fragment"><div class="line">$ date; echo &#39;dblp/inproceedings [ title =~ m/.*[Dd]ata.*/ ] return &quot;---\n&quot; ; &#39; | time  java -cp &quot;.:./antlr-4.7.2-complete.jar:./commons-cli-1.2.jar:./xpp3-1.1.4.jar:./testxpp&quot; --enable-preview -Xms10m -Xmx20m Match -s -xeasax -ea -i ~/myLocal/xmldata/dblp/dblp.xml &gt; /dev/null; date</div>
<div class="line">2020年 6月22日 月曜日 00時42分29秒 JST</div>
<div class="line">       98.62 real        98.39 user         2.79 sys</div>
<div class="line">2020年 6月22日 月曜日 00時44分07秒 JST</div>
</div><!-- fragment --><h1>200620 Sat, 9:00-11:30 ヒープメモリ枯渇問題</h1>
<p>最新のDBLPデータを入手した(2020.6.17 version)。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">単位   </th><th class="markdownTableHeadRight">行数   </th><th class="markdownTableHeadRight">単語数   </th><th class="markdownTableHeadRight">サイズ    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">バイト   </td><td class="markdownTableBodyRight">70,287,723   </td><td class="markdownTableBodyRight">166,925,105   </td><td class="markdownTableBodyRight">2,904,329,429byte    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">概算   </td><td class="markdownTableBodyRight">70M   </td><td class="markdownTableBodyRight">166M   </td><td class="markdownTableBodyRight">2.9 GB   </td></tr>
</table>
<p>このDBLPデータ上で、dblpクエリを走らせたところ、ヒープメモリが枯渇して停止するバグが発生した。これは、フレームスタック<code>FrameStackUni</code>の文字列データスタックへのアクセスで、<code>StringAdder</code>から<code>get</code>で生成される一時的な<code>String</code>オブジェクトが確保できなくなっていた。</p>
<p>メモリリークと想定して、一時的な<code>String</code>オブジェクトのデータフローを追跡したところ、こちらはフレームスタックから仮想機械<code>OVMachine</code>の文字列スタックへの移動では、<code>String</code>オブジェクトのメモリへの捕捉は起きていないことがわかった。</p>
<p>最終的に、コンパイラの改修で、<code>AstLet</code>によりLet文を導入した際に、トップレベルの<code>$DOC</code>クエリが、ターゲットクエリの出力全てを、文字列バッファ にいったん格納し、<code>post</code>コードでバッファの内容を出力ストリームに書き出していたことがわかった。</p>
<p>そこで解決として、出力ストリームへの書き出しコードを、ターゲットクエリのリターン部へ移動して、ターゲットクエリの照合が成功するごとに、直ちにターゲット文書の出力を行うようにコンパイラを修正した。</p>
<h2>DBLPデータ上での走行実験</h2>
<p>DBLPデータ全体で、JVMの最小最大メモリをそれぞれ10mbと20mbで指定して、下記のクエリを走らせた。走査器は（-xeオプション）、xppでは実行時エラーが生じて実行できなかったため、asaxのみで実験した。</p>
<p>352sec (5.86min)で全ての文書を走査した。18,863,943文書を走査し、208,849個の照合を出力した。使用メモリは、計算全体を通じて、MacOSXのactivity monitorで約46〜48mb前後だった。コマンドwcによるDBLPの走査が12.3secなので、Xscanは約30倍(=28.7倍)の時間を要したことがわかる。</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">dblp.xml (2.9GB)   </th><th class="markdownTableHeadRight">wcコマンド   </th><th class="markdownTableHeadRight">Xscan   </th><th class="markdownTableHeadRight">比率    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">計算時間 (sec)   </td><td class="markdownTableBodyRight">12.3   </td><td class="markdownTableBodyRight">352   </td><td class="markdownTableBodyRight">30x = 28.7x    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">計算時間 (min)   </td><td class="markdownTableBodyRight">0.2   </td><td class="markdownTableBodyRight">5.9   </td><td class="markdownTableBodyRight">30x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">速度 (MB/sec)   </td><td class="markdownTableBodyRight">235.77   </td><td class="markdownTableBodyRight">8.239   </td><td class="markdownTableBodyRight">0.035 = 3.5%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">メモリ概算   </td><td class="markdownTableBodyRight">-   </td><td class="markdownTableBodyRight">40MB   </td><td class="markdownTableBodyRight">-   </td></tr>
</table>
<div class="fragment"><div class="line">#入力XMLデータのサイズ</div>
<div class="line">$ time wc ~/myLocal/xmldata/dblp/dblp.xml</div>
<div class="line"> 70287723 166925105 2904329429 /Users/arim/myLocal/xmldata/dblp/dblp.xml</div>
<div class="line">real    0m12.282s user  0m10.980s sys   0m0.811s</div>
<div class="line"> </div>
<div class="line">#クエリを走らせる</div>
<div class="line">$ echo &#39;dblp/inproceedings [ title =~ m/.*([Dd]ata|[Ll]anguage).*/ ] return </div>
<div class="line">  &quot;{{$nm}}:{{$nr}}: PY[{{year}}] AU[{{author return &quot;{{ text() }}; &quot; }}] </div>
<div class="line">  TI[{{title}}] \n&quot; ; &#39; </div>
<div class="line">| time  java -cp &quot;.:./antlr-4.7.2-complete.jar:./commons-cli-1.2.jar</div>
<div class="line">  :./xpp3-1.1.4.jar:./testxpp&quot; --enable-preview -Xms10m -Xmx20m </div>
<div class="line">  Match -s -xeasax -ea -i ~/myLocal/xmldata/dblp/dblp.xml</div>
<div class="line"> </div>
<div class="line">（中略）</div>
<div class="line">@eventreader: { num requests:314959517, num instances:3 }</div>
<div class="line">@matches: { numEventsRead:314959516, numVisits:18863943, numMatches:208849, numSkipped:0 }</div>
<div class="line">      352.23 real       341.13 user        13.17 sys</div>
<div class="line">date;</div>
<div class="line">2020年 6月20日 土曜日 11時35分02秒 JST</div>
</div><!-- fragment --><h1>出力の有無</h1>
<p>出力をstdoutに出した場合と、/dev/nullへ出した場合では、約14.3の計算時間の違いだった。それほど出力ストリームの影響はなく、90％以上のほとんどの時間が、内部処理のCPU時間だと思われる。</p>
<ul>
<li>r = (352.23 - 301.75)/352.23 = 0.1433 = 14.3%</li>
</ul>
<p>メモリ設定 -Xms10m -Xmx20m, mem=47.1MB </p><div class="fragment"><div class="line">$ date; echo &#39;dblp/inproceedings [ title =~ m/.*[Dd]ata.*/ ] return &quot;---\n&quot; ; &#39; | time  java -cp &quot;.:./antlr-4.7.2-complete.jar:./commons-cli-1.2.jar:./xpp3-1.1.4.jar:./testxpp&quot; --enable-preview -Xms10m -Xmx20m Match -s -xeasax -ea -i ~/myLocal/xmldata/dblp/dblp.xml &gt; /dev/null; date</div>
<div class="line">      301.75 real       297.55 user         7.96 sys</div>
</div><!-- fragment --><h1>JVMの最大ヒープサイズの影響</h1>
<p>下記の2通りのヒープサイズ設定で、計算速度の差は 0.03 = 3程度であった。 なお、比較は出力を行わない設定で行っている。これより、JVMの最大ヒープサイズの影響は大きくないといえる。</p>
<p>メモリ設定 -Xms10m -Xmx20m, mem=47.1MB </p><div class="fragment"><div class="line">$ date; echo &#39;dblp/inproceedings [ title =~ m/.*[Dd]ata.*/ ] return &quot;---\n&quot; ; &#39; | time  java -cp &quot;.:./antlr-4.7.2-complete.jar:./commons-cli-1.2.jar:./xpp3-1.1.4.jar:./testxpp&quot; --enable-preview -Xms10m -Xmx20m Match -s -xeasax -ea -i ~/myLocal/xmldata/dblp/dblp.xml &gt; /dev/null; date</div>
<div class="line">      301.75 real       297.55 user         7.96 sys</div>
</div><!-- fragment --><p>メモリ設定 -Xms120m -Xmx140m, mem=113mb前後 </p><div class="fragment"><div class="line">$ date; echo &#39;dblp/inproceedings [ title =~ m/.*[Dd]ata.*/ ] return &quot;---\n&quot; ; &#39; | time  java -cp &quot;.:./antlr-4.7.2-complete.jar:./commons-cli-1.2.jar:./xpp3-1.1.4.jar:./testxpp&quot; --enable-preview -Xms120m -Xmx140m Match -s -xeasax -ea -i ~/myLocal/xmldata/dblp/dblp.xml  &gt; /dev/null; date</div>
<div class="line">      293.49 real       290.59 user         4.13 sys</div>
</div><!-- fragment --><h1>200509 Sat, 24:00-23:00 型推論再訪</h1>
<p>考えてみたところ、次のことがわかった。</p>
<h2>表記の導入</h2>
<p>型全体の集合を</p>
<p>$$\sig T := \op{String}, \op{Boolean}, \op{Number}, \op{Integer}, \op{Double} </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 5 2021 06:36:27 for asax02.neo by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
