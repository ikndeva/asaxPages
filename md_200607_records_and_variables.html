<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asax02.neo: 200607 XScan2: 実行環境におけるメモリと変数</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="myextrastysheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">asax02.neo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_200607_records_and_variables.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">200607 XScan2: 実行環境におけるメモリと変数 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>200607RecordsAndVariables.md,</p>
<p>200607: Created by Hiroki Arimura, <a href="#" onclick="location.href='mai'+'lto:'+'ari'+'m@'+'ist'+'.h'+'oku'+'da'+'i.a'+'c.'+'jp'; return false;">arim@<span style="display: none;">.nosp@m.</span>ist.<span style="display: none;">.nosp@m.</span>hokud<span style="display: none;">.nosp@m.</span>ai.a<span style="display: none;">.nosp@m.</span>c.jp</a></p>
<p>$\newcommand{\sig}[1]{{\cal #1}}$</p>
<h1>あらまし</h1>
<p>構造ストリームのパターン照合器であるXScanシステムの第4世代版は、マスタープロセスと作業プロセス間でのメッセージ通信によるイベントベース制御と、構文的通用範囲規則をもつ並行プロセス実行を組み合わせた処理系として、記述できる。以下では、その実行環境における概念と実装方法の説明を与える。とくに、</p>
<ul>
<li>論理的な対象である変数と、</li>
<li>その物理的な実体であるレコード、さらに、</li>
<li>プロセスの物理的な実体であるフレーム</li>
</ul>
<p>について、説明する。</p>
<h1>概要：手続きとプロセス</h1>
<p>プログラムは、一回の実行において一つだけ存在する。多数の仕事（タスク）を並行して行う時は、個々の仕事は、手続きとして書かれたプロセスとして存在する。手続きはすべて、一つのプログラムに所属せねばならない。</p>
<p>手続きの実体は、命令の列であるブロックである。手続きは、名前なしでも名前付きでも良い。</p>
<p>プロセスは、親プロセスの実行のある時点で、手続きから<code>spawn</code>されることで生存を開始する。さらに、指定されたイベントに対応して、最初に呼び出されるときに、メモリ上に実体化される（<code>wakeup</code>）。さらにイベントに対して呼び出される度に、メモリや環境から値を読み出して、計算を実行し、メモリ上の値を変化させて仕事を行い、ふたたび休眠する（<code>sleep</code>）。メモリの変化は、自分または先祖のプロセスのメモリに読み書きを行うことで行う。さいごに、仕事を終えると共に、メモリから消去されて、消滅する（<code>terminate</code>）。</p>
<h1>構文：手続き</h1>
<h2>変数</h2>
<p>変数はプログラム中に出現する名前をもったオブジェクトである。変数IDは、プログラム中で同じ名前の変数は同一な変数IDをもつように対応付けられた一意な非負整数である。</p>
<p>この変数の同一性は、変数管理者<code>VariableManager</code>によって管理される。 管理者は、プログラム全体でただ一つ存在する。管理者は、変数名の文字列をキーとして、変数IDを値とする辞書をもち、与えられた変数名$xname$を対応する変数ID $xid := intern(xname)$ に変換することで、一意性を管理する。</p>
<p>後述する通用範囲規則を用いた変数宣言によって、同じ名前の変数であっても、その出現位置が異なれば、異なるメモリオブジェクトの実態を指すことができる。</p>
<h2>変数の構文的な通用範囲規則</h2>
<p>基本として、変数は、それを宣言する最内のブロックに対応して、メモリ上に**格納場所**（memory location）をもつ。同じ変数がプログラム内の複数の場所で宣言されているときに、プログラムのある場所における変数が、どの格納場所の値に対応するかを決めるルールが必要である。これを変数の**通用範囲規則**（scope rule）と呼ぶ。</p>
<p>本クエリ言語では、変数の通用範囲として、構文的通用範囲の規則（lexical scope rule）を採用する。</p>
<p>任意の変数$x$の宣言に対して、その変数は、宣言を含む最内のブロック（$x$の宣言ブロック）の内部で、プログラムの字面上で、その内側に出現する$x$の別の宣言の通用範囲を除いた範囲で使用できる（可視である）とするものである。</p>
<p>逆にいうと、構文的通用範囲規則により、変数$x$の各出現位置は、それを含む最内の$x$の宣言ブロックに対応する変数宣言を指すことになる。</p>
<h1>計算：プロセス</h1>
<h2>メモリ</h2>
<p>**メモリ**は、変数レコードの並びである。変数レコードは、0番から始まる番地（添字）でアクセスできる。</p>
<h2>レコード</h2>
<p>**レコード**は、実行環境におけるメモリの最小単位であり、次の三つの組みである:</p>
<ul>
<li>変数 - <code>int vid</code>.</li>
<li>型 - <code>XType xtype</code>.</li>
<li>即値 - <code>int val</code>.</li>
</ul>
<p>型情報も<code>int</code>で表すと、一つのレコードは <code>3* sizeof(int)</code> バイトで表現できる。レコードには、変数の固定サイズの情報のみを格納し、<code>Double</code>や<code>String</code>型など、さまざまなサイズのメモリオブジェクトは、型情報をガイドとして、サテライトデータとして別の場所に格納する。詳しくは、次の通りである。</p>
<p>**即値型**の表現として、型が<code>Immediate</code>のとき、レコードは、即値が保持する書き換え可能な<code>int</code>型の値を表す。**非即値型**の表現として、型が<code>Immediate</code>型以外の値オブジェクトや値コンテナは、型ごとに独立して保持するデータ置き場（data store）のセルにおき、 型<code>xtype</code>とセルのポインタ<code>val</code>の対で指し示す。</p>
<p>本実行環境では、メモリは、FIFO的にスタックとして、伸長および縮小する。これにともない、要素のレコードは生成および消滅をする。 大局的な構造として、メモリは、0番からはじまる添字をもつ**レベル**に分割されている。最初は、レベルはメモリ全体を表す0番のみである。</p>
<p>今、最上位が第n-1番までのレベルをもつとき、以下の演算を、この順で実行可能である：</p>
<ul>
<li><code>pushLevel()</code>演算は、現在の第n-1レベルを終端し、その上に第nレベルを開始する。</li>
<li><code>pushFrame()</code>演算は、最上位の第n番レベルの末尾に、フレームと呼ばれる連続した領域の利用を開始する。次のフレームを追加するか、次の第n+1レベルを積むまでは、<code>addRecord()</code>演算によって任意の回数だけ、フレームの末尾に、初期化された新しいレコードを追加可能である。</li>
<li><code>popLevel()</code>演算は、現在の最上位レベルである第nレベルのすべてのレコードをまとめて消去し、最上位レベルを第n-1レベルに戻す。</li>
</ul>
<p>レコードの追加と除去は、StackによりFIFO的に行われるが、追加と除去は非対称的であることに注意されたい。レコードの追加は、ひとつづつ末尾に行うことができる。一方で、レコードの除去は、<code>popLevel()</code>演算によって、連続したメモリ末尾の連続した領域をまとめて消去する形でのみ行われる。指定したレコードを個々に任意の順序で廃棄することはできない。</p>
<h2>ブロックの実装：フレーム</h2>
<p>実行中のプログラムにおいて、一つのブロックは、メモリ上の一つのフレームとして実現される。一つのフレームは、メモリ上の連続した位置を占める可変個のレコードの並びである。フレームは、固定長のヘッダー部分と、可変長の変数部分に分けられる。</p>
<p>固定長のヘッダー部分は、次のレコードからなる</p>
<ul>
<li>手続きへのポインタ <code>rid</code>。呼び出しオブジェクトに<code>rid</code>と<code>fid</code>の対を記録することで、省略できる。</li>
<li>親フレームへのポインタ <code>pid</code>。後述するスコープ鎖を実現するために必要である。</li>
</ul>
<p>可変長の変数部分は、変数と値の対を表す次のレコードからなる</p>
<ul>
<li>局所変数と値の情報。</li>
</ul>
<p>補助構造として、与えられたフレームID <code>fid</code> から、フレームの開始番地（フレームポインタ）<code>fp := FP[fid]</code> を得るための配列<code>FP</code>を別にもつ。</p>
<p>フレームがfid順にメモリ上に配置されているという仮定のもとで、IDが<code>fid</code>の**フレームの長さ**（それが含むレコード数）は、<code>flen(fid) := FP[fid+1] - FP[fid]</code> として計算できる。ただし、FPの添字は0から始まるとし、<code>fid &gt;= len(FP)</code> となる任意の添字に対して <code>FP[fid] := len(FP)</code> と定義する。</p>
<p>手続きが<code>nargs</code>個の仮引数（arguments）をもつ場合には、それらを局所変数部分の先頭の連続した領域に配置する。これは、手続きの最初の<code>wakeup</code>の際に、実行環境が親プロセスから値をコピーして、初期化すると約束する。</p>
<ul>
<li>「値による呼び出し」であれば、「深いコピー」により、新たにデータ領域にコンテナをとり、親からの値をコピーする。この場合、仮引数を自由に書き換えても、親の実引数に反映されない。</li>
<li>「参照による呼び出し」であれば、「浅いコピー」により、親のレコードの各フィールドのみを、子レコードにコピーし、データ領域に新たに値コンテナをとらない。この場合、仮引数を書き換えると、親の実引数が書き換わる。</li>
</ul>
<p>一般に呼び出し元の先祖のフレームに値を戻すには、後述のスコープ鎖に基づいて、目標フレームの発見を経由した格納場所の取得が必要である。一方で、サブクエリの試行回数の計数などのように、直接の親のフレームに対して繰り返し値を書き戻す場合には、上記の「参照による呼び出し」のテクニックで、対象のデータストアに直接書き込むことで、型判定や格納場所の取得を省略できる。これらの選択は、プログラムのコンパイル時の最適化として選択するのが良いだろう。</p>
<h2>スコープ鎖に基づく値の取得（inter-frame fetch）</h2>
<p>この構文的な適用範囲規則は、プログラムにおいて、任意の深さの手続きの入れ子定義を許した場合には、複雑な規則になる。その実装方法が、スコープ鎖を用いたフレームの実装である。</p>
<p>この実装方法では、任意のフレームの情報は、フレームID<code>fid</code>またはフレームポインタ<code>fp</code>で指定される。 フレームの情報が与えられたとき、それが含む変数レコードに対応する値は、次のようにスコープ鎖（scope chain）を用いて取得（fetch）される。変数の全体集合を$\sig V$とおく。</p>
<p>変数$x \in \sig V$の値は次のように取り出される。</p>
<ul>
<li>現在のフレーム$f$において、$r.vid = x$となるレコード$r \in f$を探す。</li>
<li>もしあれば、レコードの型情報$\tau = r.type$と即値$p := r.val$を用いて、値 $fetch(x, f) := Stack_{\tau}[p]$ を返す。</li>
<li>もし$f$が$x$をもつレコードを含まなければ、$f := f.parent$として、現在のフレームを親のフレームで置き換える。</li>
<li>$x$を含むレコードをもつフレームが見つかるまで上記のステップを繰り返す。見つかれば、その値を返す。</li>
<li>最終的に、$f = null$ となっても、$x$のレコードが見つからないとき、値取得エラーとして、パニックモードで停止する。</li>
</ul>
<h2>フレーム内での値の取得（intra-frame lookup）</h2>
<p>現在のフレーム$f$において、$r.vid = x$となるレコード$r \in f$を探すには、</p>
<ul>
<li>フレームサイズが小さい場合には、フレームをレコードのリストとして、先頭から線形探索を行う簡単な実装を用いる。</li>
<li>フレームサイズが大きい場合には、各フレームに対して、変数名$x \in \sig V$をキーとする辞書（ハッシュ表など）を持たせて、変数から定数時間でそれを含むレコードを取り出せるようにする。</li>
</ul>
<h2>最適化1: スコープ鎖の縮約</h2>
<p>スコープ鎖には、変数を含まない固定ヘッダーだけのフレームは不要である。したがって、各フレームは、</p>
<ul>
<li>性質：変数部が空でない最近先祖(NCA)フレームへのポインタをもつ</li>
</ul>
<p>を満たすようにすると良い。</p>
<p>フレームの<code>pfid</code>リンクは次のように管理する。新しいフレーム$f$を生成する時に、先祖全てがこの性質を満たすと仮定しよう。</p>
<ul>
<li>もしその親$pf = f.parent$の変数サイズが非ゼロならば、<code>f.pfid := pf</code>と親のフレームIDを格納する。</li>
<li>空ならば <code>f.pfid := pf.pfid</code>と親のリンクを引き継ぐ。</li>
</ul>
<h2>最適化2：動的な変数表</h2>
<p>もしプログラムの全ての変数が、実行の任意の時点で、メモリ上にただ1箇所だけ場所をもつこと（一意な変数の生存箇所）が保証されている場合があったと仮定する。どのように、これを検出するかはあとで議論する。</p>
<p>このとき、プログラム中の任意の変数をキーとして、</p>
<ul>
<li>任意の実行時点における生存変数の出現フレーム番号、または、</li>
<li>非生存の際は<code>null</code>を格納する</li>
</ul>
<p>動的な辞書を用いることで、定数時間で値の取得を行える。ただし、この表は、<code>pushLevel</code>と<code>popLevel</code>の二つの演算に伴う、フレームの生成と消滅に合わせて、動的に管理される。 </p><h1>EOF</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jun 24 2020 23:20:08 for asax02.neo by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
