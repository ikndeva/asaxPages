<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>asax02.neo: Match.java</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="myextrastysheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">asax02.neo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_md__match.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Match.java </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>2019-09-09, Hiroki Arimura, Hokkaido University (<a href="#" onclick="location.href='mai'+'lto:'+'ari'+'m@'+'ist'+'.h'+'oku'+'da'+'i.a'+'c.'+'jp'; return false;">arim@<span style="display: none;">.nosp@m.</span>ist.<span style="display: none;">.nosp@m.</span>hokud<span style="display: none;">.nosp@m.</span>ai.a<span style="display: none;">.nosp@m.</span>c.jp</a>) </p><h1>Source</h1>
<p>Match.java</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">import</span> java.lang.*;</div>
<div class="line"><span class="keyword">import</span> java.util.*;</div>
<div class="line"><span class="keyword">import</span> java.io.*;</div>
<div class="line"><span class="keyword">import</span> org.apache.commons.cli.*; <span class="comment">//CLI option parser</span></div>
<div class="line"><span class="keyword">import</span> java.nio.charset.*;  <span class="comment">//Charset</span></div>
<div class="line"><span class="keyword">import</span> java.nio.file.*; <span class="comment">//Files.readString</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//private packages</span></div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespaceutil.html">util</a>.*;</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespaceutil.html">util</a>.<a class="code" href="classutil_1_1_trace_level.html">TraceLevel</a>.*;</div>
<div class="line"><span class="keyword">import</span> <span class="keyword">static</span> <a class="code" href="namespaceutil.html">util</a>.<a class="code" href="classutil_1_1_multi_words_option.html">MultiWordsOption</a>.*;</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespaceio.html">io</a>.*; </div>
<div class="line"><span class="keyword">import</span> <span class="keyword">event</span>.*; </div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespaceparse.html">parse</a>.*; </div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespacemachine.html">machine</a>.*;</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespacemachine.html">machine</a>.<a class="code" href="interfacemachine_1_1_context.html">Context</a>.*; </div>
<div class="line"><span class="keyword">import</span> <a class="code" href="namespaceast.html">ast</a>.*; </div>
<div class="line"><span class="comment">//import static util.TraceLevel.*; </span></div>
<div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</div>
<div class="line"><span class="comment">//import static ast.machine.Runnable.*; //for Codelet</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/// </span></div>
<div class="ttc" id="aclassutil_1_1_multi_words_option_html"><div class="ttname"><a href="classutil_1_1_multi_words_option.html">util.MultiWordsOption</a></div><div class="ttdoc">アパッチCLIのオプションパーザーのヘルパークラス．</div><div class="ttdef"><b>Definition:</b> MultiWordsOption.java:36</div></div>
<div class="ttc" id="aclassutil_1_1_trace_level_html"><div class="ttname"><a href="classutil_1_1_trace_level.html">util.TraceLevel</a></div><div class="ttdoc">ログ出力用のトレースレベルを扱うクラス。</div><div class="ttdef"><b>Definition:</b> TraceLevel.java:26</div></div>
<div class="ttc" id="ainterfacemachine_1_1_context_html"><div class="ttname"><a href="interfacemachine_1_1_context.html">machine.Context</a></div><div class="ttdoc">実行系の記憶機構（環境）を抽象化したインタフェース.</div><div class="ttdef"><b>Definition:</b> Context.java:20</div></div>
<div class="ttc" id="anamespaceast_html"><div class="ttname"><a href="namespaceast.html">ast</a></div><div class="ttdoc">抽象構文木のパッケージ</div><div class="ttdef"><b>Definition:</b> AstAssign.java:7</div></div>
<div class="ttc" id="anamespaceio_html"><div class="ttname"><a href="namespaceio.html">io</a></div><div class="ttdoc">低レベル文字ストリーム入出力のパッケージ</div></div>
<div class="ttc" id="anamespacemachine_html"><div class="ttname"><a href="namespacemachine.html">machine</a></div><div class="ttdoc">実行系のパッケージ</div><div class="ttdef"><b>Definition:</b> Assignable.java:5</div></div>
<div class="ttc" id="anamespaceparse_html"><div class="ttname"><a href="namespaceparse.html">parse</a></div><div class="ttdoc">ANTLRパーザとヘルパーのパッケージ</div><div class="ttdef"><b>Definition:</b> AstNodeFactory.java:5</div></div>
<div class="ttc" id="anamespaceutil_html"><div class="ttname"><a href="namespaceutil.html">util</a></div><div class="ttdoc">ユティリティーのパッケージ</div><div class="ttdef"><b>Definition:</b> ArgTest.java:4</div></div>
</div><!-- fragment --><p> /// java -cp .:./prog:./antlr-4.7.1-complete.jar:./commons-cli-1.2.jar <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match</a> -h /// usage: Axes [-b ARG] [-c] [-d] [-e ARG] [-i ARG] [-j] [-m ARG] /// [-n] [-o ARG] [-r] [-s] [-t ARG] [-v] [-w] [-x] [-y] [-z] /// -b,&ndash;blocksize ARG Experimental: Set input block size. (default /// 2048) /// -c,&ndash;complement-mode the mode to complement missing end tags. /// (default false) /// -d,&ndash;printxml printing the input in a DEBUG format. (default /// false) /// -e,&ndash;inputCharset ARG Input java Charset in UTF-8 (default), /// ISO-8859-1, UTF-16, etc /// -i,&ndash;input ARG Input file. '-' indicates stdin (default) /// -j,&ndash;printjson printing the input in JSON format. (default /// false) /// -m,&ndash;maxbuf ARG Experimental: Set maximum buffer size. (default /// 1000*000 = 1MB) /// -n,&ndash;nonverbose Surpress print log info /// -o,&ndash;output ARG Output file. '-' indicates stdout (default) /// -r,&ndash;print event traces printing event traces. (default false) /// -s,&ndash;stdin set the input to stdin. (default false) /// -t,&ndash;tracelevel ARG Set trace level. (default 1) /// -v,&ndash;verbose Print log info (default) /// -w,&ndash;exact-text-mode Exactly print possibly white-space-only texts /// without omitting them /// -x,&ndash;printxml printing the input in a simple XML format. /// (default false) /// -y,&ndash;readtestpooledins read test with PooledInputStream (default /// false) /// -z,&ndash;readtestrawins read test with Reader for read test (default /// false) /// ``` /// /// コマンドラインの実行例. /// ``` /// $echo input.xml | javaexec <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match</a> /// ``` /// /// Javaプログラムからの利用例. /// ``` /// <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match</a> app = new <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match()</a>; /// EventReadable eis = /// new AsaxEventReader( /// new BufferedReader( /// new InputStreamReader(System.in, "UTF8"))); /// app.setupAsaxEventReader(eis); /// /// //メインループ：入力ストリームを走査する /// for (Event ev: eis) { /// ;//イベント ev を用いて何かする /// } /// app.reportAsaxEventReader(eis); //実行結果のレポート /// eis.close(); /// ``` public class <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match</a> { </p><pre class="fragment">//==============================
// Constants
//==============================
final static boolean DEBUG_DECORA = false; //debug
final static boolean HAS_ARG = true; //getopt: do not change!
final static boolean NO_ARG = false; //getopt: do not change!
static YamlBuf yaml = new YamlBuf(); 
static YamlBuf yamlsub = new YamlBuf(); 
public static TraceLevel LOG = new TraceLevel();

//tentative 
//final static boolean DEBUG_TRACE_LEVEL = false; //debug

//==============================
// Members
//==============================
String inputCharset = "UTF-8"; 
String queryCharset = "UTF-8"; 
int BLKSIZE = 0; 
int MAXBUF = 0; 
boolean TO_COMPLEMENT_TAGS  = false; //level 1
boolean TO_PRINT_EVENT      = false; //option r
boolean TO_PRINT_QUERY_ONLY = false; //option d
boolean TO_PRINT_OPTION     = false; //suboption d o
boolean TO_PRINT_STATS      = false; //option s
//==
enum WriteFormat { XML, JSON, NONE }; 
boolean TO_WRITE = false; //note: not used yet!
WriteFormat WRITE_FORMAT = WriteFormat.XML;  
//==

// int tracelevel = 0;
List&lt;String&gt; infiles  = null; 
public String outfile = null;
String queryFile = null;
String queryString = null;
XMachine XM = null; //パターン照合機械
XCompiler XC  = null; //クエリプログラムのコンパイラ
machine.Runnable prog = null;
boolean isStdinUsed = false; //入力でのstdinの重複仕様のチェック用

//====
// trace level 
private TraceLevel.Level __local_trace_level__ = TraceLevel.Level.NONE;

void updateLocalTraceLevel(TraceLevel.Level level) {
if (level.level() &gt; __local_trace_level__.level())
    __local_trace_level__ = level; 
}

// void updateLocalTraceLevel(int level) {
//  __local_trace_level__ = Math.max(__local_trace_level__, level);
// }

public void setTraceLevelMatch() {
LOG.setLevel(__local_trace_level__);
this.XC.setTraceLevel(__local_trace_level__); //サブモに移譲
this.XM.setTraceLevel(__local_trace_level__); //サブモに移譲
// XCompiler.setTraceLevel(__local_trace_level__); //サブモに移譲
// XMachine.setTraceLevel(__local_trace_level__); //サブモに移譲
}

//====
// Constructor 

/** テキスト処理オブジェクトを生成する.  */
public 
Match() {
initOption();
this.XC = new XCompiler();
}

public machine.Runnable compile(InputStream is) throws IOException {
if (LOG.LEVEL(Level.VERBOSE)) out.println("@XC.compile..."); 
this.prog = this.XC.compile(is);
if (LOG.LEVEL(Level.VERBOSE)) out.println("@XM.create..."); 
this.XM = new XMachine(this.prog);
return this.prog; 
}

//==============================
// Options
//==============================
//オプションの定義を追加
Options opts = new Options();

// this.opts.addOption("i", HAS_ARG, "infile");
// // opts.addOption("i", "--input", HAS_ARG,
// //          "input file. \'-\' indicates stdin (default)");

CommandLineParser optParser = new GnuParser();
CommandLine cmd = null;

void initOption() {
//xcompiler
opts.addOption("a", "print_all", HAS_ARG,
           "Setting print range for a query (default: false)");
//match 
opts.addOption("c", "charset", HAS_ARG,
           "Specify the charset for the query and input stream encoding: ISO-8859-1, UTF-16, etc (default UTF-8)");
//debug with suboptions
opts.addOption("d", "debug", HAS_ARG,
           "Printing debug infomation with suboptions. (default false)"
           +"\n-de: a switch for tentative experiments"
           +"\n-dd: print the height in a query (with -a)"
           +"\n-dt: print the type info in a query (with -a)"
           +"\n-do: print an opject name in a query (with -a)"
           +"\n-dn: print with noend NL (with -a)"
           +"\n-dp: print the trace of parsing"
           +"\n-dq: print a query and then stop. Equivalent to -pn"
           +"\n-dx: set tentatively DEBUG options"
           +"\n-d other options: Setting trace level to DEBUG");
//match 
opts.addOption(MultiWordsOption.createOption("e", "query", HAS_ARG, "Setting a query string"));
// opts.addOption("e", "query", HAS_ARG, "Setting a query string");
//xcompiler
opts.addOption("f", "set_fold_level", HAS_ARG,
           "Setting folding level for printing from 0 to some bound");
//match 
opts.addOption("i", "input", HAS_ARG,
           "Input file. \'-\' indicates stdin (default)");
// //experimental
// opts.addOption("j", "printjson", NO_ARG,
//         "printing the input in JSON format. (default false)");
//other options
opts.addOption("n", "nonverbose", NO_ARG,
           "Surpress print log info");
//match 
opts.addOption("o", "output", HAS_ARG,
           "Output file. \'-\' indicates stdout (default)");
//match 
opts.addOption("p", "debug", HAS_ARG,
           "Printing matches. (default false)"
           +"\n-pj: print in JSON"
           +"\n-px: print in XML"
           +"\n-pn: print no matches /wo scan. Equivalent to -dq"
           +""); 
//xcompiler
opts.addOption("q", "query", HAS_ARG,
           "Query file. \'-\' indicates stdin (default)");

//experimental
opts.addOption("r", "print event traces", NO_ARG,
           "printing event traces. (default false)");
//match 
opts.addOption("s", "stat", NO_ARG,
           "Printinng statistics of run. (default false)");
//experimental
opts.addOption("t", "set_trace_level", HAS_ARG,
           "Setting trace level for printing from 0 to some bound");
//other options
opts.addOption("u", "exact-text-mode", NO_ARG,
           "Exactly print possibly white-space-only texts without omitting them");
//other options
opts.addOption("v", "verbose", NO_ARG,
           "Print log info (default)");
// //experimental
// opts.addOption("x", "printxml", NO_ARG,
//         "printing the input in a simple XML format. (default false)");
//match 
opts.addOption("x", "experimental", HAS_ARG,
           "Experimental options"
           +"\n-xb blocksize:\tSet input block size. (default 2048)"
           +"\n-xm: bufsize: \tSet maximum buffer size. (default 1MB)"
           +""); 
// //experimental
// opts.addOption("m", "maxbuf", HAS_ARG,
//         "Experimental: Set maximum buffer size. (default 1000*000 = 1MB)");
// opts.addOption("b", "blocksize", HAS_ARG,
//         "Experimental: Set input block size. (default 2048)");
// opts.addOption("x", "printxml", NO_ARG,
//         "printing the input in a simple XML format. (default false)");
//experimental
opts.addOption("y", "readtestpooledins", NO_ARG,
           "read test with PooledInputStream (default false)");
//experimental
opts.addOption("z", "readtestrawins", NO_ARG,
           "read test with Reader for read test (default false)");
}

String getSubSubOpt(String subOpt) {
assert subOpt != null; 
if (subOpt.length() == 0) return null; 
else return subOpt.substring(0,1); 
}

String getSubSubArg(String subOpt) {
assert subOpt != null; 
if (subOpt.length() &lt;= 1) return null; 
else return subOpt.substring(1,subOpt.length()); 
}

void readOptionAndArgs(String[] args) {
TraceLevel.Level level_;
String subOpt; 

//System.out.println("debug0:"+" TraceLevel="+LOG.getLevel()+" TO_PRINT_STATS="+this.TO_PRINT_STATS+"");

try {
    this.cmd = this.optParser.parse(this.opts, args);
    //==========
    // Process options 
    //==========

    //Options from XMCompiler
    if (cmd.hasOption("a")) { //option -a: XMに移譲
    XCompiler.setOptionQueryPrintRange(cmd.getOptionValue("a"));
    TO_PRINT_QUERY_ONLY = true;
    }

    //match: option -c charset
    if (cmd.hasOption("c")) {
    this.queryCharset = this.inputCharset = cmd.getOptionValue("c");
    }

    //match: option -e query
    if (cmd.hasOption("e")) {
    this.queryString = MultiWordsOption.getOptionValue(cmd, "e");
    }

    //astnode: -f 
    if (cmd.hasOption("f")) {
    if (DEBUG_DECORA) out.println("option: f");     
    this.XC.NF.setFoldHeight(Integer.parseInt(cmd.getOptionValue("f"))); 
    // this.XC.NF.setFoldHeight(Integer.parseInt(cmd.getOptionValue("f"))); 
    }

    //option d with suboptions d (-dd) and t (-dt)
    //- note: option d no longerset tracelevel
    if (cmd.hasOption("d")) {
    if (DEBUG_DECORA) out.println("option: d");
    subOpt = cmd.getOptionValue("d");
    level_ = Level.DEBUG; 
    if (subOpt == null) {
        if (DEBUG_DECORA) out.println("option: subOpt==null");
    } else {
        if (DEBUG_DECORA) out.println("option: subOpt=='"+subOpt+"'");
        for (int beg = 0; beg &lt; subOpt.length(); beg++) {
        String charStr = subOpt.substring(beg, beg+1); 
        // switch(subOpt) {
        switch(charStr) {
        case "d": //option -dd or -d d
            if (DEBUG_DECORA) out.println("suboption: dd");
            this.XC.NF.printState().hgt = true; 
            break;
        case "e": //option -de or -d e: printing query with no end newlines
            this.XC.NF.printState().noend = false; 
            break;
        case "o": //option -do or -d o 
            if (DEBUG_DECORA) out.println("suboption: do");
            this.XC.NF.printState().obj = true; 
            // AstNode.nodeform.TO_PRINT_OBJECT = true; 
            break;
        case "p": //option -dq or -d q 
            AstParser.DEBUG_PARSING = true; 
            XCompiler.DEBUG_PARSING = true; 
            break;
        case "q": //option -dq or -d q 
            TO_PRINT_QUERY_ONLY = true;
            //System.out.println("debug: option -dq: TO_PRINT_QUERY_ONLY="+TO_PRINT_QUERY_ONLY); 
            break;
        case "t": //option -dt or -d t 
            if (DEBUG_DECORA) out.println("suboption: dt");
            this.XC.NF.printState().type = true; 
            //AstNode.nodeform.TO_PRINT_TYPE = true;

            break;
        case "x": //option -dx. tentative DEBUG
            AstNode.DEBUG_EVAL = true; 
            break;
        default:
            out.println("warning no such a suboption for -d: "+subOpt);
            break; 
        }//switch
        }//for
    }//if 
    }//end option d

    //match: option -i infile
    if (cmd.hasOption("i")) { //default stdin
    if (this.infiles == null) this.infiles = new ArrayList&lt;String&gt;();
    this.infiles.add(cmd.getOptionValue("i"));
    }

    //match:option -o outfile
    if (cmd.hasOption("o")) 
    this.outfile = cmd.getOptionValue("o");

    //=====
    //option p with suboptions
    if (cmd.hasOption("p")) {
    subOpt = cmd.getOptionValue("p");
    //XMachine.TO_PRINT_MATCH = true;
    XMachine.setToPrintMatch(true); 
    if (subOpt == null) {
        ; //do nothing
    } else {
        //out.println("option p with suboption: "+subOpt);
        //print mode in { XML, JSON, OTHER }
        switch(subOpt) {
        case "x": //option -px: print in XML
        this.WRITE_FORMAT = WriteFormat.XML;
        XMachine.pmode = PrintMode.XML; 
        break;
        case "j": //option -pj: print in JSON
        this.WRITE_FORMAT = WriteFormat.JSON;
        XMachine.pmode = PrintMode.JSON; 
        break;
        case "o": //option -pj: print in JSON
        this.WRITE_FORMAT = WriteFormat.JSON;
        XMachine.pmode = PrintMode.OTHER; 
        break;
        case "n": //option -pn: no print
        //TO_PRINT_QUERY_ONLY = true; 
        this.WRITE_FORMAT = WriteFormat.NONE;
        XMachine.pmode = PrintMode.NONE; 
        break;
        default:
        out.println("warning: no such a suboption for -d: "+subOpt);
        XMachine.pmode = PrintMode.OTHER; 
        ; //change nothing
        break; 
        }
    }
    }//end option p
    //=====

    //option -q queryFile
    if (cmd.hasOption("q")) {
    this.queryFile = cmd.getOptionValue("q");
    }

    //option -s or -stdin 
    if (cmd.hasOption("s")) { //-stdin
    System.out.println("option: set: TO_PRINT_STATS = true"); 
    TO_PRINT_STATS = true; 
    }

    //option -t level 
    if (cmd.hasOption("t")) {
    level_ = TraceLevel.parseLevel(cmd.getOptionValue("t"));
    updateLocalTraceLevel(level_); 
    }

    if (cmd.hasOption("v")) {
    updateLocalTraceLevel(Level.VERBOSE); 
    }

    //option -n (--nonverbose)
    if (cmd.hasOption("n")) {
    updateLocalTraceLevel(Level.NONE); 
    }

    //=====
    //experimental: option x with suboptions
    if (cmd.hasOption("x")) {
    subOpt = cmd.getOptionValue("x");
    if (subOpt == null) {
        ; //do nothing
    } else {
        //out.println("option x with suboption: "+subOpt);
        assert subOpt != null; 
        assert subOpt.length() &gt; 0; 
        String subSubOpt = getSubSubOpt(subOpt); 
        String subSubArg = getSubSubArg(subOpt);
        out.println("debug: 'option -x': "+yaml.clear()
            .add("subSubOpt", subSubOpt)
            .add("subSubArg", subSubArg)
            .toString()
            ); 
        switch(subSubOpt) {
        case "b": //option -xb//option -b blocksize
        // this.BLKSIZE = new Integer(subSubArg);
        this.BLKSIZE = Integer.parseInt(subSubArg);
        break;
        case "m": //option -xm//option -b maximum buffer size
        this.MAXBUF = Integer.parseInt(subSubArg);
        // this.MAXBUF = new Integer(subSubArg);
        break;
        default:
        out.println("warning: no such a suboption: "
                +subOpt);
        break; 
        }
    }
    }//end option p

    //System.out.println("debug: end of options!");

    //==========
    // Process the rest of arguments
    //==========

    //残りの引数はすべて入力ファイルと解釈して、配列infilesへ加える. 
    for (String infile : cmd.getArgs()) {
    if (this.infiles == null) this.infiles = new ArrayList&lt;String&gt;();
    infiles.add(infile);
    }
    // Processing input streams
    if (LOG.LEVEL(Level.TRACE)) System.out.println("debug: postprocessing input files"); 
    this.complementInputFiles(); //process stdin

    //==========
    // Post processing
    //==========

    if (LOG.LEVEL(Level.TRACE)) {
        out.println("options: ");
        for (Option anOpt : cmd.getOptions()) {
            out.println("- "+yaml.clear()
            .add("name", anOpt.getOpt())
            .add("arg", "\""+Util.nullableToString(anOpt.getValue())+"\"")
            .toString());
        }
    }

    if (LOG.LEVEL(Level.VERBOSE))
    out.println(this.yaml.clear()
            .add("arguments",
             this.yamlsub.clear()
             .add("infiles", this.infiles.toString())
             .add("queryFile", this.queryFile)
             .toString()
             ).toSeq()); 

    this.setTraceLevelMatch(); //propage tracelevel to all submodules

}
catch(ParseException e) { //print the usage string
        HelpFormatter help = new HelpFormatter();
        help.printHelp("Match", this.opts, true);
        Util.exit();
}
}//readOptionAndArgs

void complementInputFiles() {
if (this.infiles != null) return; 
this.infiles = new ArrayList&lt;String&gt;();
this.infiles.add("-"); //insert the unique stdin as an input stream 
}

static boolean hasEmptyFile(String filename) {
if (filename == null) return true;
else if (filename.equals("-")) return true;
else return false; 
}

static boolean hasEmptyFile(List&lt;String&gt; filenames) {
if (filenames == null) return true;
for (String file : filenames) 
    if (hasEmptyFile(file)) return true;
return false;
}

//==============================
// Status of the stack machine 
//==============================

int depth = 0;


/********************************************************
 * Main routine
 ********************************************************/    

//Experimental: ASR特有のオプションを設定する
void setupAsaxEventReader(EventReadable eis) {
if (eis instanceof AsaxEventReader) {
    AsaxEventReader ais_ = (AsaxEventReader)eis; 
    ais_.LOG.setLevel(LOG.getLevel());
    if (this.cmd.hasOption("b")) //option -b blocksize
    ais_.setBLKSIZE(this.BLKSIZE); 
    if (this.cmd.hasOption("m")) //option -b max.buffer size
    ais_.setMAXBUF(this.MAXBUF);
    if (this.cmd.hasOption("u")) //option -w exact-text-mode
    ais_.setEXACT_TEXT_MODE(true);
}
}

//Experimental: ASR特有の統計を報告する
void reportAsaxEventReader(EventReadable eis) {
if (eis instanceof AsaxEventReader) {
    AsaxEventReader ais = (AsaxEventReader)eis;
    //ais.yaml.setToFold(true);
    ais.yaml.setToFold(false);
    if (LOG.LEVEL(Level.VERBOSE)) {
    out.println(this.yaml.setToQuote(true).clear()
            .add("data read so far", ais.reportYaml())
            .toString()); 
    }
}
}

///@brief クエリ文字列と文字セット名文字列をうけとり，対応する入力ストリームを返す．
InputStream createQueryStream() throws ParseException
{
InputStream qs = null;
String srcType = null; 
try {
    //case: クエリが，オプション-eで文字列として与えられている．
    if (this.queryString != null) {
    srcType = "argment(-e)"; 
    if (LOG.LEVEL(Level.TRACE)) out.println("@read a query from a string...");
    }
    else {
    InputStream ins = null; 
    //case: クエリが，オプション-qでテキストファイルとして与えられている．
    if (this.queryFile == null || this.queryFile.equals("-")) {
        srcType = "stdin"; 
        if (this.isStdinUsed) throw new ParseException("stdin: already used!");
        else this.isStdinUsed = true;
        ins = System.in; 
    }
    //case: クエリがstdinから与えられる．
    else {
        srcType = "file:\'"+this.queryFile+"\'"; 
        ins = new FileInputStream(this.queryFile); 
    }
    this.queryString = Util.readStringFromInputStream(ins);
    }
    String csname = "UTF8";     
    if (LOG.LEVEL(Level.VERBOSE))
    System.out.println("@query["+srcType+"]: ["+Util.trimBothEnds(this.queryString, Util.CHAR_SPACE, Util.CHAR_SPACE)+"]"); 
    this.queryString = Util.sqeezeEscape(this.queryString);
    qs = Util.createInputStreamFromString(this.queryString, this.queryCharset); 
}
catch (IOException e) {
    Util.errorExit("createQueryStream: IOExeption: fail to open");
}

return qs; 
}

InputStream createInputDocumentStream(String infile)
throws FileNotFoundException 
{
InputStream ins = null;
if (infile == null || infile.equals("-")) {
    if (this.isStdinUsed)
    throw new FileNotFoundException("stdin has already been used!: infile="+infile); 
    ins = System.in;
    this.isStdinUsed = true; 
}
else 
    ins = new FileInputStream(infile); //FileNotFoundException
return ins; 
}

public static void main(String[] args) 
{
Match app = new Match();
app.readOptionAndArgs(args);

//System.out.println("debug: main: "+" TraceLevel="+LOG.getLevel()+" TO_PRINT_STATS="+app.TO_PRINT_STATS+"");

try {
    //==========
    // Processing query stream

    //System.out.println("debug: main: 1: createQueryStream");
    InputStream queryStream = app.createQueryStream(); 

    //System.out.println("debug: main: 2: compile"); 
    app.compile(queryStream);

    if (app.TO_PRINT_QUERY_ONLY) {
    if (LOG.LEVEL(Level.VERBOSE))
        out.println("exit by option -dq..."); 
    System.exit(0);
    }
    assert(Charset.isSupported(app.inputCharset));

    //==========
    // Processing input streams
    if (LOG.LEVEL(Level.VERBOSE)) out.println("@MT.processing all inputs...");
    int numIns = 0; 
    for (String infile : app.infiles) {
    if (LOG.LEVEL(Level.VERBOSE))
        out.println("@processing input stream["+numIns+"]: "+infile);

    //======== process a single input file ========
    //Setup input stream
    int numInputEvents = 0;
    InputStream ins = app.createInputDocumentStream(infile); 
    EventReadable eis =
        new AsaxEventReader(new BufferedReader(new InputStreamReader(ins, app.inputCharset)));
    app.setupAsaxEventReader(eis); //その他のオプションの設定


//メインループ：入力ストリームを走査する
    //Env scope = null;

    //========== Main event loop: begin ==========
    for (Event ev: eis) {
        //if (app.TO_PRINT_EVENT) eos.writeEvent(ev); //イベントを出力

        if (LOG.LEVEL(Level.DEBUG2)) {
        yaml.clear().openObj()
            .add("ev.type", ev.getType().toString())
            .add("ev.data", ev.getName())
            .add("ev.text", ev.getText())
            // .add("sc.lv", scope.getLevel())
            // .add("sc.name", scope.getName())
            // .add("sc.text", scope.getText())
            .closeObj();
        System.out.println("Match.event: "+yaml.toString());
        }

        //exec 
        app.XM.exec(ev);
        // app.XM.exec(ev, scope);

        numInputEvents++;
        if (ev.getType() == Event.EventType.EOF) break; 
    }
    //========== Main event loop: end ==========
    if (LOG.LEVEL(Level.VERBOSE)) app.reportAsaxEventReader(eis); //実行結果のレポート
    eis.close();
    if (LOG.LEVEL(Level.VERBOSE)) out.println("@processing done ["+numIns+"]: "+infile);        
    //to ignore the rest of input files
    if (infile.trim().equals("-")) break;
    //========== end Parser par.run() ==========
    numIns++; 
    } //for
}
catch(FileNotFoundException e) {
    System.out.println(e);
    System.exit(0);
} //catch
catch(Exception e) {
    e.printStackTrace();
    System.exit(1);
} //catch

if (LOG.LEVEL(Level.VERBOSE) || app.TO_PRINT_STATS)
    out.println(yaml.clear().add("Match.done", app.XM.repoRunYaml()).toSeq()); 

}//method main
</pre><p> }//class <a class="el" href="class_match.html" title="AsaxEventReaderを用いた簡単な構造テキストの操作器の実装例.">Match</a></p>
<p>//EOF</p>
<p>``` </p><h2>EOF</h2>
<p>2019-09-09 02:41:33, generated by gawk -f mkmd from Match.java </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 29 2021 18:42:54 for asax02.neo by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
